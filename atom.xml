<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Michael`Blog</title>
  
  
  <link href="http://michael8023.github.io/atom.xml" rel="self"/>
  
  <link href="http://michael8023.github.io/"/>
  <updated>2023-08-04T09:03:00.108Z</updated>
  <id>http://michael8023.github.io/</id>
  
  <author>
    <name>Michael Liu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LSTM</title>
    <link href="http://michael8023.github.io/post/48c60d0d.html"/>
    <id>http://michael8023.github.io/post/48c60d0d.html</id>
    <published>2023-08-03T08:52:33.000Z</published>
    <updated>2023-08-04T09:03:00.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h1><blockquote><p>REFERENCE：<a href="https://blog.csdn.net/v_JULY_v/article/details/89894058?ops_request_misc=%7B%22request%5Fid%22%3A%22169098645416800213056045%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169098645416800213056045&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-89894058-null-null.142^v92^insert_down28v1&amp;utm_term=LSTM&amp;spm=1018.2226.3001.4187">如何从RNN起步，一步一步通俗理解LSTM_rnn lstm_v_JULY_v的博客-CSDN博客</a><br><a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">Understanding LSTM Networks — colah’s blog</a></p><p>RNN与传统神经网络不同的是可以获取先前的信息，相当于把多个神经网络连接在一起。<img src="https://s1.ax1x.com/2023/08/03/pPiOJfO.png" alt="img"></p><p>RNN的局限：长期依赖问题</p><p>​    当需要的信息和当前信息的位置非常远的情况下，RNN就会失去这种连接到先前信息的能力，换言之，RNN具有短时记忆，所以我们需要一种结构可以有选择性的存储或者遗忘先前的信息。</p><p>RNN的变体——LSTM可以在一定程度上解决梯度消失和梯度爆炸这两个问题</p></blockquote><p>LSTM可以学习只保留相关信息来预测，并忘记不相关的数据。</p><p><img src="https://s1.ax1x.com/2023/08/03/pPiOU6H.png" alt="img"></p><p><img src="https://s1.ax1x.com/2023/08/03/pPiO00I.png" alt="img"></p><p>与RNN相比加入了三个sigmoid函数，有利于更新或者忘记信息</p><ul><li>任何数乘以0都得0，这部分信息就删除</li><li>乘以1得到本身，信息保留</li></ul><p>LSTM拥有三种类型的门结构：遗忘门/忘记门、输入门和输出门，来保护和控制细胞状态。下面，我们来介绍这三个门。</p><h3 id="忘记门-遗忘门"><a href="#忘记门-遗忘门" class="headerlink" title="忘记门/遗忘门"></a>忘记门/遗忘门</h3><p>读取上一个输出和当前输入，做一个sigmoid非线性映射，然后输出一个向量（向量每一个维度都在0到1之间），最后与细胞状态$C_{t-1}$相乘<img src="https://s1.ax1x.com/2023/08/03/pPiOrAP.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/33d34e6909bd9e989fbf7094d97890c4.gif" alt="img"></p><h3 id="输入门"><a href="#输入门" class="headerlink" title="输入门"></a>输入门</h3><p>确定什么样的新信息被存放在细胞状态中，其中</p><ul><li>sigmoid层决定什么值我们需要更新</li><li>tanh层创建一个新的候选向量$\widetilde{C_t}$，会被加入到状态中</li></ul><p><img src="https://s1.ax1x.com/2023/08/03/pPiXKC8.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/cc4a872a1f878a945c6afd912a6e2ff5.gif" alt="img"></p><h3 id="细胞状态"><a href="#细胞状态" class="headerlink" title="细胞状态"></a>细胞状态</h3><p>把旧状态与$f_t$相乘，丢弃掉不需要的信息，接着加上$i_t*\widetilde{C_t}$这就是新的候选值<img src="https://s1.ax1x.com/2023/08/03/pPiXQgg.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/3c9d64c8ac82b985769cb0903891dabe.gif" alt="img"></p><h3 id="输出门"><a href="#输出门" class="headerlink" title="输出门"></a>输出门</h3><p>基于细胞状态，通过tanh进行处理，得到一个-1到1之间的值，并将它和sigmoid门的输出相乘</p><blockquote><p>在语言模型的例子中，因为他就看到了一个代词，可能需要输出与一个动词相关的信息。例如，可能输出是否代词是单数还是负数，这样如果是动词的话，我们也知道动词需要进行的词形变化，进而输出信息。</p></blockquote><p><img src="https://s1.ax1x.com/2023/08/03/pPiX8Ds.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/fc0d3305d75e0bb3b77602ffc524843e.gif" alt="img"></p><h3 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h3><p>将<strong>忘记门和输入</strong>合成了一个单一的更新门。同样还混合了细胞状态和隐藏状态。</p><p><img src="https://s1.ax1x.com/2023/08/03/pPiXGbn.png" alt="img"></p><p>$1-z_t$是需要忘记的，而$r_t$相当于是一个备份，最终在$\widetilde{h}$做了一个tanh的变化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LSTM&quot;&gt;&lt;a href=&quot;#LSTM&quot; class=&quot;headerlink&quot; title=&quot;LSTM&quot;&gt;&lt;/a&gt;LSTM&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;REFERENCE：&lt;a href=&quot;https://blog.csdn.net/v_JULY_v</summary>
      
    
    
    
    <category term="学习" scheme="http://michael8023.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="神经网络" scheme="http://michael8023.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>激活函数</title>
    <link href="http://michael8023.github.io/post/f86c970.html"/>
    <id>http://michael8023.github.io/post/f86c970.html</id>
    <published>2023-08-02T13:35:50.000Z</published>
    <updated>2023-08-04T09:02:14.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用的激活函数以及优缺点分析"><a href="#常用的激活函数以及优缺点分析" class="headerlink" title="常用的激活函数以及优缺点分析"></a>常用的激活函数以及优缺点分析</h1><blockquote><p>activation function：旨在帮助网络学习数据中的复杂模式，对所有的隐藏层和输出层添加一个非线性的操作，使得输出更为复杂，表达能力更强。</p></blockquote><h3 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h3><script type="math/tex; mode=display">f(x)=\frac{1}{1+e^{-x}}</script><p><img src="https://s1.ax1x.com/2023/08/02/pPPOFbt.png" alt="img"></p><p>优点：</p><ol><li>值域为[0，1]，可用于将预测概率作为输出的模型，比如用于表示二分类的类别或者用于表示置信度。</li><li>对每个神经元的输出进行了归一化。</li><li>函数连续可导，可以提供平滑的梯度值，防止模型训练过程中出现梯度突变。</li></ol><p>不足：</p><ol><li>由于导数特性，反向传播时会出现梯度消失，参数更新缓慢</li><li>输出大于0，下一层会得到上一层输出全为正信号</li><li>需要指数运算，计算量大。</li></ol><h3 id="Tanh函数"><a href="#Tanh函数" class="headerlink" title="Tanh函数"></a>Tanh函数</h3><script type="math/tex; mode=display">f(x)=\frac{e^x-e^{-x}}{e^x+e^{-x}}</script><p><img src="https://s1.ax1x.com/2023/08/02/pPPOn2Q.png" alt="img"></p><p>优点：</p><ol><li>完全可微分，反对称，对称中心在原点</li><li>打破网络层与网络层之间的线性关系，区间[-1，1]</li><li>一般tanh用于隐藏层，sigmoid用于输出层</li></ol><p>缺点：</p><ol><li>两端梯度较小</li><li>需要指数运算</li><li>层数较多时，反向传播链式求导，多项相乘，函数进入饱和区（导数接近于0的地方），梯度消失</li></ol><h3 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h3><script type="math/tex; mode=display">f(x)=\begin{cases}x,x\geq 0\\0,x<0\end{cases}</script><p><img src="https://s1.ax1x.com/2023/08/02/pPPOMKs.png" alt="img"></p><p>优点：</p><ol><li>正输入是线性的，收敛速度快。</li><li>输入大于0时，梯度为1，有效比卖你梯度消失和梯度爆炸。</li><li>生物学启发，输入为负值的时候，神经元无效。</li></ol><p>缺点：</p><ol><li>负值时会产生“Dead Neuron”。</li><li>输出不是以0为中心的。</li></ol><h3 id="Leaky-ReLU"><a href="#Leaky-ReLU" class="headerlink" title="Leaky ReLU"></a>Leaky ReLU</h3><script type="math/tex; mode=display">f(x)=\begin{cases}x,x\geq0\\\lambda x,x<0\end{cases},\lambda\in(0,1)</script><p><img src="https://s1.ax1x.com/2023/08/02/pPPO3V0.png" alt="img"></p><p>优点：</p><ol><li>与ReLU相比，把非常小的线性分量给予负输入来调整零梯度的问题，有助于扩大ReLU的范围</li><li>使得负轴信息不会全部丢失，确保训练模型过程中神经元权重在输入小于0的时候依然会得到更新</li></ol><p>缺点：</p><ol><li>减少静默神经元，慢速的梯度学习</li><li>实践未证明效果更好</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用的激活函数以及优缺点分析&quot;&gt;&lt;a href=&quot;#常用的激活函数以及优缺点分析&quot; class=&quot;headerlink&quot; title=&quot;常用的激活函数以及优缺点分析&quot;&gt;&lt;/a&gt;常用的激活函数以及优缺点分析&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;activatio</summary>
      
    
    
    
    <category term="学习" scheme="http://michael8023.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="神经网络" scheme="http://michael8023.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>get_density_map_gaussian</title>
    <link href="http://michael8023.github.io/post/ebade0e1.html"/>
    <id>http://michael8023.github.io/post/ebade0e1.html</id>
    <published>2023-07-15T09:57:24.000Z</published>
    <updated>2023-08-04T09:03:13.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="get-density-map-gaussian"><a href="#get-density-map-gaussian" class="headerlink" title="get_density_map_gaussian"></a>get_density_map_gaussian</h1><blockquote><p>参考博客：<a href="https://github.com/gjy3035/C-3-Framework/blob/python3.x/datasets/get_density_map_gaussian.m">C-3-Framework/datasets/get_density_map_gaussian.m at python3.x · gjy3035/C-3-Framework (github.com)</a></p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">%matlab+注释</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">im_density</span> = <span class="title">get_density_map_gaussian</span><span class="params">(im,points,k_size,sigma)</span></span></span><br><span class="line"><span class="comment">%im:输入图像</span></span><br><span class="line"><span class="comment">%points:一个矩阵，每一行包含一个点的坐标，表示人群中人的位置</span></span><br><span class="line"><span class="comment">%k_size:高斯核的大小</span></span><br><span class="line"><span class="comment">%sigma:高斯核的标准差</span></span><br><span class="line"></span><br><span class="line">im_density = <span class="built_in">zeros</span>(<span class="built_in">size</span>(im)); <span class="comment">%生成一个全0的矩阵，用于装载密度图</span></span><br><span class="line">[h,w] = <span class="built_in">size</span>(im_density);<span class="comment">%获取输入图像的宽高</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">length</span>(points)==<span class="number">0</span>)<span class="comment">%如果没有人的信息，直接返回</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%     GJY</span></span><br><span class="line"><span class="comment">% if(length(points(:,1))==1)</span></span><br><span class="line"><span class="comment">%     x1 = max(1,min(w,round(points(1,1))));</span></span><br><span class="line"><span class="comment">%     y1 = max(1,min(h,round(points(1,2))));</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line"><span class="comment">%     im_density(y1,x1) = 255;</span></span><br><span class="line"><span class="comment">%     return;</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">size</span>(points,<span class="number">1</span>) <span class="comment">%遍历points中的每一行</span></span><br><span class="line">    f_sz = k_size;</span><br><span class="line"><span class="comment">%     sigma = 4.0;</span></span><br><span class="line">    H = fspecial(<span class="string">&#x27;Gaussian&#x27;</span>,[f_sz, f_sz],sigma);<span class="comment">%生成一个二维高斯滤波器</span></span><br><span class="line">    x = <span class="built_in">min</span>(w,<span class="built_in">max</span>(<span class="number">1</span>,<span class="built_in">abs</span>(int32(<span class="built_in">floor</span>(points(<span class="built_in">j</span>,<span class="number">1</span>)))))); <span class="comment">%计算x和y的坐标并保证符合条件</span></span><br><span class="line">    y = <span class="built_in">min</span>(h,<span class="built_in">max</span>(<span class="number">1</span>,<span class="built_in">abs</span>(int32(<span class="built_in">floor</span>(points(<span class="built_in">j</span>,<span class="number">2</span>))))));</span><br><span class="line">    <span class="keyword">if</span>(x &gt; w || y &gt; h)<span class="comment">%如果超过范围则直接跳过</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    x1 = x - int32(<span class="built_in">floor</span>(f_sz/<span class="number">2</span>)); y1 = y - int32(<span class="built_in">floor</span>(f_sz/<span class="number">2</span>));<span class="comment">%计算矩形左上角和右下角的坐标</span></span><br><span class="line">    x2 = x + int32(<span class="built_in">floor</span>(f_sz/<span class="number">2</span>)); y2 = y + int32(<span class="built_in">floor</span>(f_sz/<span class="number">2</span>));</span><br><span class="line">    dfx1 = <span class="number">0</span>; dfy1 = <span class="number">0</span>; dfx2 = <span class="number">0</span>; dfy2 = <span class="number">0</span>;<span class="comment">%需要调整的偏移量</span></span><br><span class="line">    change_H = <span class="built_in">false</span>;<span class="comment">%标志是否需要调整</span></span><br><span class="line">    <span class="keyword">if</span>(x1 &lt; <span class="number">1</span>)</span><br><span class="line">        dfx1 = <span class="built_in">abs</span>(x1)+<span class="number">1</span>;</span><br><span class="line">        x1 = <span class="number">1</span>;</span><br><span class="line">        change_H = <span class="built_in">true</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span>(y1 &lt; <span class="number">1</span>)</span><br><span class="line">        dfy1 = <span class="built_in">abs</span>(y1)+<span class="number">1</span>;</span><br><span class="line">        y1 = <span class="number">1</span>;</span><br><span class="line">        change_H = <span class="built_in">true</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span>(x2 &gt; w)</span><br><span class="line">        dfx2 = x2 - w;</span><br><span class="line">        x2 = w;</span><br><span class="line">        change_H = <span class="built_in">true</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span>(y2 &gt; h)</span><br><span class="line">        dfy2 = y2 - h;</span><br><span class="line">        y2 = h;</span><br><span class="line">        change_H = <span class="built_in">true</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    x1h = <span class="number">1</span>+dfx1; y1h = <span class="number">1</span>+dfy1; x2h = f_sz - dfx2; y2h = f_sz - dfy2;<span class="comment">%调整后的方框左上角和右下角的坐标</span></span><br><span class="line">    <span class="keyword">if</span> (change_H == <span class="built_in">true</span>)</span><br><span class="line">        H =  fspecial(<span class="string">&#x27;Gaussian&#x27;</span>,[double(y2h-y1h+<span class="number">1</span>), double(x2h-x1h+<span class="number">1</span>)],sigma);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    im_density(y1:y2,x1:x2) = im_density(y1:y2,x1:x2) +  H;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pyhton</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> gaussian_filter</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_density_map_gaussian</span>(<span class="params">im,points,k_size,sigma</span>):</span><br><span class="line">    im_density=np.zeros(im)</span><br><span class="line">    h,w=np.shape(im_density)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(points)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> points:</span><br><span class="line">        f_sz=k_size</span><br><span class="line">        H=gaussian_filter(im_density,sigma)</span><br><span class="line">        x=<span class="built_in">min</span>(w,<span class="built_in">max</span>(<span class="number">1</span>,<span class="built_in">abs</span>(<span class="built_in">int</span>(np.floor(points(j,<span class="number">1</span>))))))</span><br><span class="line">        y=<span class="built_in">min</span>(h,<span class="built_in">max</span>(<span class="number">1</span>,<span class="built_in">abs</span>(<span class="built_in">int</span>(np.floor(points(j,<span class="number">2</span>))))))</span><br><span class="line">        <span class="keyword">if</span> x&gt;w|y&gt;h:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        x1=x-<span class="built_in">int</span>(f_sz//<span class="number">2</span>)</span><br><span class="line">        y1=y-<span class="built_in">int</span>(f_sz//<span class="number">2</span>)</span><br><span class="line">        x2=x+<span class="built_in">int</span>(f_sz//<span class="number">2</span>)</span><br><span class="line">        y2=y+<span class="built_in">int</span>(f_sz//<span class="number">2</span>)</span><br><span class="line">        change_H=<span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> x1&lt;<span class="number">1</span>:</span><br><span class="line">            dfx1 = <span class="built_in">abs</span>(x1)+<span class="number">1</span></span><br><span class="line">            x1 = <span class="number">1</span></span><br><span class="line">            change_H = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> y1&lt;<span class="number">1</span>:</span><br><span class="line">            dfy1 = <span class="built_in">abs</span>(y1)+<span class="number">1</span></span><br><span class="line">            y1 = <span class="number">1</span></span><br><span class="line">            change_H = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> x2 &gt; w:</span><br><span class="line">            dfx2 = x2 - w</span><br><span class="line">            x2 = w</span><br><span class="line">            change_H = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> y2&gt;h:</span><br><span class="line">            dfy2=y2-h</span><br><span class="line">            y2=h</span><br><span class="line">            change_H=<span class="literal">True</span></span><br><span class="line">        x1h = <span class="number">1</span>+dfx1; y1h = <span class="number">1</span>+dfy1; x2h = f_sz - dfx2; y2h = f_sz - dfy2</span><br><span class="line">        <span class="keyword">if</span> change_H==<span class="literal">True</span>:</span><br><span class="line">            H=gaussian_filter((y2h-y1h+<span class="number">1</span>, x2h-x1h+<span class="number">1</span>),sigma)</span><br><span class="line"></span><br><span class="line">        im_density[y1-<span class="number">1</span>:y2,x1-<span class="number">1</span>:x2]+= H</span><br><span class="line">    <span class="keyword">return</span> im_density</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;get-density-map-gaussian&quot;&gt;&lt;a href=&quot;#get-density-map-gaussian&quot; class=&quot;headerlink&quot; title=&quot;get_density_map_gaussian&quot;&gt;&lt;/a&gt;get_density_ma</summary>
      
    
    
    
    <category term="学习" scheme="http://michael8023.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="人群计数" scheme="http://michael8023.github.io/tags/%E4%BA%BA%E7%BE%A4%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>CSRNet</title>
    <link href="http://michael8023.github.io/post/135f215e.html"/>
    <id>http://michael8023.github.io/post/135f215e.html</id>
    <published>2023-07-13T14:25:30.000Z</published>
    <updated>2023-08-04T09:02:14.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSRNet-note"><a href="#CSRNet-note" class="headerlink" title="CSRNet_note"></a>CSRNet_note</h1><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><ul><li>A network for congested scene recognition</li><li>Composed of 2 major componets: <ul><li>a CNN as the front-end for 2D feature extraction</li><li>a dilated CNN for the back-end, use dilated kernels to deliver larger reception fields and to replace pooling operations.</li></ul></li><li>Easy-trained model</li><li>Great performance in count estimation</li></ul><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h3><ul><li>MCNN  has large amount of training time and non-effective branch structure</li><li>CSRNet uses pure CNNto suport flexible resolutions</li><li>we use 3x3 filters to limit the network complexity</li><li>We deploy the first 10 layers fromVGG-16 as the front-end and dilated convolution layers as the back-end to enlarge receptive fields and extract deeper features without losing resolutions (since pooling layers are not used)</li></ul><h3 id="3-Proposed-Solution"><a href="#3-Proposed-Solution" class="headerlink" title="3 Proposed Solution"></a>3 Proposed Solution</h3><p>​    deeper CNN</p><p><strong>front-end</strong>:  remove the classification part of VGG-16 (fully-connected layers) and build the proposed CSRNet with convolutional layers in VGG-16</p><p><strong>back-end</strong>: deploy dilated convolutional layers as the back-end for extracting deeper information of saliency as well as maintaining the output resolution.</p><h4 id="3-1-1-Dilated-convolution-空洞卷积"><a href="#3-1-1-Dilated-convolution-空洞卷积" class="headerlink" title="3.1.1 Dilated convolution 空洞卷积"></a>3.1.1 Dilated convolution 空洞卷积</h4><p>A 2-D dilated convolution can be defined as follow:</p><script type="math/tex; mode=display">y(m,n)=\sum^M_{i=1}\sum^N_{j=1}x(+r\times i,n+r\times j)w(i,j)</script><p>$r$ is the dilation rate.If $r=1$, is a normal convoltion</p><p><img src="https://img01.anheyu.com/useruploads/0/2023/07/13/64affe5b177bc.png" alt="dilated convolution"></p><p>​    Pooling layers reduce the <strong>spatial resolution</strong>(空间分辨率), dilated convolution is a good alternative of pooling layer. In dialated convolution, a small-size kernel with $k\times k$ filter is enlarged to $k+(k-1)(r-1)$ with dilated stride $r$.</p><p><img src="https://img01.anheyu.com/useruploads/0/2023/07/13/64b000fe4a32e.png" alt="dilated convolution"></p><h4 id="3-1-2-Network-configuration"><a href="#3-1-2-Network-configuration" class="headerlink" title="3.1.2 Network configuration"></a>3.1.2 Network configuration</h4><ul><li>When targeting the same size of receptive field, using more conv layers with small kernels is more efficient than using fewer layers with larger kernels.</li></ul><p><img src="https://img01.anheyu.com/useruploads/0/2023/07/13/64b0024c42b7a.png" alt="Network configuration"></p><h4 id="3-2-Training-method"><a href="#3-2-Training-method" class="headerlink" title="3.2 Training method"></a>3.2 Training method</h4><p>​    By blurring each head annotationusing a Gaussian kernel (which is normalized to 1), we generate the ground truth considering the spatial distribution of all images from each dataset.</p><script type="math/tex; mode=display">F(x)=\sum^N_{i=1}\delta(x-x_i)\times G_{\sigma_i}(x),\,with \,\sigma_i=\beta\overline{d_i}</script><p>   (the same as MCNN)</p><p><strong>Data augmentation</strong>—crop 9 patches from each img at different locations with $\frac{1}{4}$size of the original img,4 patches without overlapping,5 patches are randomly corpped from the input img.</p><p>loss function:</p><script type="math/tex; mode=display">L(\Theta)=\frac{1}{2N}\sum_{i=1}||Z(X_i;\Theta)-Z_i^{GT}||^2_2</script><script type="math/tex; mode=display">MAE=\frac{1}{N}\sum^N_{i=1}|C_i-C_i^{GT}|\\MSE=\sqrt{\frac{1}{N}\sum^N_{i=1}|C_i-C_i^{GT}|^2}\\C_i=\sum^L_{l=1}\sum^W_{w=1}z_l,w</script><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://arxiv.org/pdf/1802.10062.pdf">CSRNet</a></p><p>[2] <a href="https://blog.csdn.net/qq_40356092/article/details/108050458">论文学习笔记：CSRNet: Dilated Convolutional Neural Networks for Understanding the Highly Congested Scenes_</a></p><p>[3] <a href="https://blog.csdn.net/becomeyee/article/details/124547377">人群密度检测-CSRnet_</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSRNet-note&quot;&gt;&lt;a href=&quot;#CSRNet-note&quot; class=&quot;headerlink&quot; title=&quot;CSRNet_note&quot;&gt;&lt;/a&gt;CSRNet_note&lt;/h1&gt;&lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot;</summary>
      
    
    
    
    <category term="学习" scheme="http://michael8023.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="人群计数" scheme="http://michael8023.github.io/tags/%E4%BA%BA%E7%BE%A4%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>MCNN_note</title>
    <link href="http://michael8023.github.io/post/1b1a2dda.html"/>
    <id>http://michael8023.github.io/post/1b1a2dda.html</id>
    <published>2023-07-13T09:02:54.000Z</published>
    <updated>2023-08-04T12:07:25.325Z</updated>
    
    <content type="html"><![CDATA[<!-- chuckle-post-ai.js可以在网页结构的任何位置插入，只要你能够 --><p><script src="source\js\chuckle-post-ai.js"></script><br><!-- 但要确保的是，AI构造代码一定要在chuckle-post-ai.js之后插入 --></p><p><script data-pjax defer>  new ChucklePostAI({    // 文章内容所在的元素属性的选择器，也是AI挂载的容器，AI将会挂载到该容器的最前面    el: '#post>#article-container',    // 驱动AI所必须的key，即是tianliGPT后端服务所必须的key    key: 'd90e7ff2968fd4a313cd',    // 文章标题所在的元素属性的选择器，默认获取当前网页的标题    title_el: '.post-title',    // 文章推荐方式，all：匹配数据库内所有文章进行推荐，web：仅当前站内的文章，默认all    rec_method: 'web',  })</script></p><h1 id="MCNN笔记"><a href="#MCNN笔记" class="headerlink" title="MCNN笔记"></a>MCNN笔记</h1><h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p>​    旨在提出一种可以从句有任意密度人群和角度的单张图像准确估计<strong>人群数量</strong>的方法。提出了一种简单的多列卷积神经网络（MCNN）,将图像映射到了它的人群密度图。<strong>MCNN允许输入图像是任意大小和分辨率。</strong></p><p>通过利用不同大小的滤波器有不同大小感受野的特点，<strong>每一列的CNN学习到的特征都能在不同的视野上适应对人头大小的变化。</strong></p><p>​    真实密度图的准确计算依赖于<strong>几何自适应核（geometry-adaptive kernels），它不需要知道输入图像的透视图（perspective map）</strong></p><blockquote><p>perspective map 是一种感知人头尺寸变化的方法。</p><p>perspective map的定义是实际中1m在图像中多少像素，是像素距离/实际距离。</p><p>针对如何产生perspective map的ground truth</p><ol><li><p>可见行人身体的<img src="https://pic3.zhimg.com/80/v2-2c2ac17d7e918a58ff746bb73fad0362_720w.webp" alt="img">如图所示，</p><script type="math/tex; mode=display">y_h=\frac{f(C-H)}{z_1},y_f=\frac{fC}{z_1}\\h=y_f-y_h=\frac{fH}{z_1}\\根据相似度h=\frac{H}{C-H}y_h\\p=\frac{h}{H}=\frac{1}{C-H}y_h</script><p>​    假设实际人的平均高度为1.75m, 我们可以在图中采样几个可以看到的人的像素身高h，然后Yh也是像素距离，可以从图中读出，这样就可以反推C，然后有了C，有了H=1.75，就可以计算不同Yh处的persepctive值pg了</p></li><li><p>对于看不到行人身体的，</p><p>像ShanghaiTechA这样的密集的dataset，图片上很难采样到body，去像上面一样推算C，来获得整个perspective map，但是我们可以根据KNN的最近邻采样方法，获得平均的一个人头尺寸，然后采样不同Yh处的人头尺寸之后，本文是采用如下的插值函数去拟合产生其他位置的perspective值的：</p><p><img src="https://pic1.zhimg.com/80/v2-87a3794c52709c157311962e5d335844_720w.webp" alt="img"></p><p>a，b，c是要拟合的参数，但是对于人头尺寸实际值H取多少，并没有说</p></li></ol></blockquote><h3 id="related-work"><a href="#related-work" class="headerlink" title="related work"></a>related work</h3><p>​    早期的方法是，在拥有两张连续帧的图片，或者视频序列这样数据的基础之上，通过提升行人的羊毛核运动特征，建立检测式的框架来估计。局限性：对于那些很密集的密封的集群下，检测器的效果往往会大打折扣，因而影响最终准确率。</p><p>​    在视频人群计数中，人们提出了<strong>追踪特征的集群轨迹</strong>。例如，[24]已经使用了高度平行版本的KLT追踪器和集群聚类方法来估算人群。[3]提出通过追踪单张图像的特征，进而从概率的方法上，通过集群分组的方法展现运动中的独立个体。然而，<strong>追踪型的方法在静止的图片上的密集人群检测依然没有奏效。</strong></p><h3 id="conrtibution"><a href="#conrtibution" class="headerlink" title="conrtibution"></a>conrtibution</h3><p>​    <strong>目的：在相机拍摄下的，任意视角和人群密集数的静止图片中预测人群数量，并达到一定的准确度。</strong></p><p>​    方法：找到一个能够自动学习有效特征的方法，卷积神经网络。</p><p>​    多列卷积神经网络：每一列卷积网络都能够学习不同尺度的特征。给MCNN输入一张图片，它将输出一个人群密度图，该图的积分就是预测的人群数量。</p><p>贡献如下：</p><ol><li>采用多列卷积网络：散列卷积网络分别对应三个不同感受野的特征（大，中，小），即使因图片分辨率或者拍摄视角而导致的不同大小的人或人头，每一列卷积网络依然能够适应</li><li><strong>用1x1卷积替换了全连接层，这样输入的图片可以是任意尺寸的而不需要resize导致失真。</strong>我们可以通过输出的密度图得到预测结果。</li><li>使用了一个新的数据集用于评估，由于视角差异（UCSD,WorldExpo’10），拥挤程度（UCSD），数据集的尺度（UCSD,UCF_CC_50）等差异，现有的数据集并不能够完全检验模型在多场景模型下的能力。<strong>因此我们推出了一个新的大型数据集—ShangHaiTech，一个拥有1200张图像，330000准确标注的人头的。</strong>据我们所知，就人头数量而言，ShangHaiTech是目前最大的数据集。在这个数据集中，你不可能找到两张相同视角下的图片。数据集分为两部分Part_A和Part_B，Part_A是从网上随机爬取的图片集，其中大部分都有很密集的人头数。Part_B是从上海的大城市地区的街道获取，并且每张图片都已经被标注，我们会把此数据集对外开放。</li></ol><h3 id="MCNN-model"><a href="#MCNN-model" class="headerlink" title="MCNN model"></a>MCNN model</h3><p>​    由于密度图可以表示更加多样的信息，并且密度图通过积分就可以获取人头数，所以决定输入一张图片，输出密度图。</p><h4 id="几何自适应高斯核生成密度图"><a href="#几何自适应高斯核生成密度图" class="headerlink" title="几何自适应高斯核生成密度图"></a>几何自适应高斯核生成密度图</h4><p>​    用训练数据生成密度图$H(x)=\sum^n_{i=0}{\delta(x-x_i)}$为了使得$H(x)$​能够连续，我们对其进行一个高斯核卷积</p><script type="math/tex; mode=display">F(x)=H(x)*G_\sigma(x)</script><blockquote><p>如果直接拿标注的图片去训练，每个像素值不是0就是 1 ，就好比蛋糕全部是你一个人吃而周围的人根本吃不到，未免也太极端了吧？而且这样模型学习也会更加困难。<br>所以，我们使用一种方法（其实这个方法就是高斯卷积核函数），它能够把像素值为 1 的地方稍微“分点”给其他所有的像素值，每个像素点都有，只是大家多多少少的问题。<br>注意！是会把这个“1”分给所有的像素，如果你的图片大小为[1024,1024]大小的分辨率，那么“1”就会被分给1024x1024个像素！</p></blockquote><p>然而这样分的话人头大小也会对结果产生影响，距离镜头近的分的多，所以恶魔应该一句图片中每个人头大小的不同，来选择拓展参数$\sigma$，我们发现人头大小往往核周边相邻的两个人头有关，我们提出和了数据自适应的方式，，也就是通过某个人头核他周边的人头平均距离来决定拓展参数。</p><p>​    对于图片中每个给定的人$x<em>i$，我们 假定 他的k近邻距离为$[d</em>{i1},d<em>{i12},d</em>{i3}…,d<em>{im}]$，那么，$x_i$的平均距离就是$\overline{d}^i=\frac{1}{m}\sum^m</em>{i=1}d_i$。因此与$x_i$相关联的像素会对应一片区域，大致是一个以$\overline{d}^i$为半径的园，高斯卷积核的变量参数$\sigma$就用$\overline{d}^i$代替，</p><script type="math/tex; mode=display">F(x)=\sum^N_1\sigma(x-x_i)*G_{\sigma i}(x),with \,\sigma i=\beta\overline{d}^i</script><p>上述方法生成密度图，称为几何自适应高斯核</p><p>$\beta$取0.3效果最好，$\beta$就是用来表征不同距离高斯分布所分数据的差异性</p><h4 id="用于训练密度图生成的多列卷积神经网络"><a href="#用于训练密度图生成的多列卷积神经网络" class="headerlink" title="用于训练密度图生成的多列卷积神经网络"></a>用于训练密度图生成的多列卷积神经网络</h4><p>使用不同感受野的卷积核从密度图中学习各自的局部特征。</p><p>MCNN的每一列都配置了不同大小的核来适应不同尺度下的特征。<img src="https://pic1.zhimg.com/80/v2-16eb074d14a409a39c591d9f3aef4b40_720w.webp" alt="img"></p><p>激活函数方面采用2x2的最大池化和ReLU激活函数的效果会比较好</p><p>为了减少参数量，更大的卷积核提取的特征图的数量更少。然后我们把3列提取的特征图在某一维度上拼凑起来，最后通过1x1卷积把这些特征图融合，并映射为预测密度图。</p><p>通过欧氏距离来评估预测密度图和真实密度图的差异。损失函数</p><script type="math/tex; mode=display">L(\Theta)=\frac{1}{2N}\sum^N_{i=1}||F(X_i;\Theta)-F_i||^2_2\\其中\Theta是可学习的参数，N是图片数量，X_i是输入的图片，F(X_i;\Theta)是预测密度图，F_i是图片真实密度图</script><h3 id="MCNN-Optimization"><a href="#MCNN-Optimization" class="headerlink" title="MCNN Optimization"></a>MCNN Optimization</h3><p>随机梯度下降法和反向传播</p><p><strong>先把三列特征提取网络分开单独训练生成密度图，之后再让他们三列一起生成特征，融合后再次预测密度图，这样就能只需要同步微调参数就可以达到不错的效果。</strong></p><h5 id="泛化性"><a href="#泛化性" class="headerlink" title="泛化性"></a>泛化性</h5><p>MCNN的优势在于他能够感受到不同尺寸的人头来生成密度图。因此，<strong>如果它能够先在一个本身人头的尺寸差异就很大的数据集上训练，那么之后它肯定也能很轻松自如地去适应别的人头大小差异并不是那么大的数据集。</strong></p><p><strong>如果某新的个领域下的训练样本很少，我们就可以固定MCNN每列前面的几个卷积层，只要微调最后的卷积层即可。</strong></p><p>参考文献：</p><p>[1]  <a href="https://zhuanlan.zhihu.com/p/592021040">人群计数论文翻译（1）MCNN - 知乎 (zhihu.com)</a></p><p>[2]  原文链接<a href="https://www.semanticscholar.org/paper/Single-Image-Crowd-Counting-via-Multi-Column-Neural-Zhang-Zhou/2dc3b3eff8ded8914c8b536d05ee713ff0cdf3cd?p2df">[PDF] Single-Image Crowd Counting via Multi-Column Convolutional Neural Network | Semantic Scholar</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- chuckle-post-ai.js可以在网页结构的任何位置插入，只要你能够 --&gt;
&lt;p&gt;&lt;script src=&quot;source\js\chuckle-post-ai.js&quot;&gt;&lt;/script&gt;&lt;br&gt;&lt;!-- 但要确保的是，AI构造代码一定要在chuckle-pos</summary>
      
    
    
    
    <category term="学习" scheme="http://michael8023.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="人群计数" scheme="http://michael8023.github.io/tags/%E4%BA%BA%E7%BE%A4%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>数字图像处理(更新)</title>
    <link href="http://michael8023.github.io/post/139de6d8.html"/>
    <id>http://michael8023.github.io/post/139de6d8.html</id>
    <published>2023-07-12T07:37:55.000Z</published>
    <updated>2023-08-04T09:01:56.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字图像处理"><a href="#数字图像处理" class="headerlink" title="数字图像处理"></a>数字图像处理</h1><ul><li>定义我们称之为图像处理领域的范围</li><li>从历史观点回顾图像处理的起源</li><li>给出图像处理技术状况的该你那</li><li>简要讨论数字图像处理中所用的主要方法</li><li>概述通用目的的典型图像处理系统的组成</li><li>列出一些文献</li></ul><h3 id="chapter1-绪论"><a href="#chapter1-绪论" class="headerlink" title="chapter1 绪论"></a>chapter1 绪论</h3><p>元素幅值称之为像素</p><p>低级处理：<strong>降低噪声</strong>的图像预处理、对比度增强和图像尖锐化</p><p>中级处理：涉及诸多任务，比如分割，减少这些目标物的描述，以使其更适合计算机处理以及对不同目标的分类</p><p>高级处理涉及<strong>理解</strong>已识别目标的总体</p><p><img src="C:\Users\11147\AppData\Roaming\Typora\typora-user-images\image-20230530115326128.png" alt="image-20230530115326128"></p><h3 id="cahpter2-数字图像基础"><a href="#cahpter2-数字图像基础" class="headerlink" title="cahpter2 数字图像基础"></a>cahpter2 数字图像基础</h3><h4 id="2-1视觉感知要素"><a href="#2-1视觉感知要素" class="headerlink" title="2.1视觉感知要素"></a>2.1视觉感知要素</h4><p>眼睛的亮度适应和辨别<br>数字图像作为离散的灰度集来显示，<strong>所以眼睛对不同亮度级别的辨别能力在图像显示中是一个重要的考虑因素</strong>。视觉系统的当前灵敏度级别称为亮度适应级别，不同的级别对应着人眼所能感知的主观亮度范围，超过这一范围的刺激都被感知为黑色。</p><h4 id="2-2光和电磁波谱"><a href="#2-2光和电磁波谱" class="headerlink" title="2.2光和电磁波谱"></a>2.2光和电磁波谱</h4><h5 id="电磁波谱描述公式"><a href="#电磁波谱描述公式" class="headerlink" title="电磁波谱描述公式"></a>电磁波谱描述公式</h5><p>==波长（λ）与频率（v）关系：$λ= c/v$ ，c为光速2.998*108 m/s==<br>各个分量的能量公式： $E= hv$， h为普朗克常数，波长单位是米（m），频率为赫兹（Hz），能量单位为电子伏特。</p><h5 id="光子定义"><a href="#光子定义" class="headerlink" title="光子定义"></a>光子定义</h5><p>电磁波可以看做是以波长λ传播的正弦波，或者可以看成事没有质量的粒子流，每个粒子以波的模式以光速传播和移动。每个无质量的粒子包含一定的（一束能量），每束能量称为一个光子。</p><h5 id="能量公式对于伽马射线的危害解释"><a href="#能量公式对于伽马射线的危害解释" class="headerlink" title="能量公式对于伽马射线的危害解释"></a>能量公式对于伽马射线的危害解释</h5><p>由能量公式与波长与频率公式可知，光子所携带能量与频率成正比，从光谱图可知，伽马射线对活体危害较其他波最大。</p><h5 id="人眼识别色彩的原因"><a href="#人眼识别色彩的原因" class="headerlink" title="人眼识别色彩的原因"></a>人眼识别色彩的原因</h5><p>人感受物体的颜色由物体反射光的性质决定。以所有可见波长相对平衡地反射光的物体，我们看到便是白色。绿色物体反射波长范围为 500-570nm 的光，而吸收其他波长的大部分能量。其他颜色是同样的。</p><h5 id="灰度级，灰度图像定义"><a href="#灰度级，灰度图像定义" class="headerlink" title="灰度级，灰度图像定义"></a>灰度级，灰度图像定义</h5><p>没有颜色的光称为单色光或无色光。 单色光的唯一属性是它的强度或大小。 因为感知单色光的强度从黑色到灰色变化，最后到白色，灰度级一词通常用来表示单色光的强度。<br>从黑到白的单色光的度量值范围通常称为灰度级．而单色图像常称为灰度图像。</p><h5 id="描述彩色光源的质量的基本量"><a href="#描述彩色光源的质量的基本量" class="headerlink" title="描述彩色光源的质量的基本量"></a>描述彩色光源的质量的基本量</h5><p>发光强度：从光源流出能量的总量,通常用瓦特（W）来度量。<br>光通量：观察者从光源感受到的能量，用==流明数（Im）==度量。如，从远红外光谱范围的光源发射出的光具有实际意义的能量，但观察者却很难感知到它。 它的光通量儿乎是零。<br>亮度：光感知的主观描绘子，它实际上不能度量。它具体体现了强度的无色概念，是描述彩色感觉的参数之一。</p><h5 id="在任意波段成像："><a href="#在任意波段成像：" class="headerlink" title="在任意波段成像："></a>在任意波段成像：</h5><p>原理上，如果可以开发出一种传感器来检测由一种电磁波谐发射的能量，那么我们就可以在该波段上对感兴趣的事件成像。 但要注意的一点是，要求“看到” 一个物体的电磁波的波长必须小于等于物体的尺寸。</p><h4 id="2-3图像感知获取"><a href="#2-3图像感知获取" class="headerlink" title="2.3图像感知获取"></a>2.3图像感知获取</h4><p><img src="https://img-blog.csdnimg.cn/a7227e7eb9344118b05dabbc3ad0f812.png" alt="在这里插入图片描述">图像产生原理：<br>多数图像都是由“照射”源和形成图像的“场景”元素对光能的反射或吸收而产生的。</p><p>==照射能量变换为数字图像==<br>原理：将输入电能和对特殊类型检测能源敏感的传感器材料相组合，把输入能源转变为电压。 ==输出电压波形是传感器的响应==，通过把传感器响应数字化，从每一个传感器到一个数字量。</p><p>单个传感器获取图像：<img src="https://img-blog.csdnimg.cn/cb6a3f99355341b8af538f6c877d4e59.png" alt="在这里插入图片描述"></p><p>条带传感器获取图像：<img src="https://img-blog.csdnimg.cn/aa694a15331f40139389957aa60ee60d.png" alt="在这里插入图片描述"></p><p>使用传感器阵列获取图像：</p><p>阵列形式排列的传感器是数组摄像机中排列的主要方式。</p><p>简单图像形成模型<br>用二维函数f(x, y)表示图像，在坐标(x, y)处，f的值或幅度是一个正的标量，其物理意义由图像源决定。<br>==函数f(x, y)可由两个分量来表征：①入射到观察场景的光源总量，即入射分量i(x, y)；②场景中物体反射光的总量，即反射分量r(x, y)；==<br>两个函数作为一个乘积合并形成f(x, y），即f(x, y) = i(x, y)r(x, y)。</p><h4 id="2-4图像取样和量化"><a href="#2-4图像取样和量化" class="headerlink" title="2.4图像取样和量化"></a>2.4图像取样和量化</h4><p>为了产生一幅数字图像，需要把连续的感知数据转换为数字形式。这种转换包括两种处理 ： 取样和量化。</p><p>取样和量化的概念：<br>一幅图像的 x 和 y 坐标及幅度可能都是连续的。 为将它转换为数字形式， 必锁在坐标上和幅度上都进行取样操作。对坐标值进行数字化称为取样，对幅值数字化称为量化。<img src="https://img-blog.csdnimg.cn/7eeaeff8acd7455d95dc855099b27bfe.png" alt="在这里插入图片描述"></p><p>数字图像的质量在很大程度上取决于取样和量化中所用的样本数和灰度级。</p><p>数字图像表示：<br>函数图：用两个坐标轴决定空间位置，第三个坐标是以两个空间变量 x 和 y 为函数的 f（灰度）值。<br>图像显示：用两个坐标轴决定空间位置，每个点的灰度与该点处的f值成正比。<br>==矩阵表示：将f(x,y）的数值简单地显示为一个阵列（矩阵）。该矩阵中的每个元素称为图像单元、图像元素或像素。==<br> <br>图像显示允许我们快速地观察结果。 数值阵列用于处理和算法开发。二者使用较多。</p><p>==数字图像的原点位于左上角==，其中正x轴向下延伸，正y轴向右延伸。<br>定义原因：①图像显示扫描大都是从左上角开始的，然后一次向下移动一行。②矩阵的第一个元素按惯例应在阵列的左上角。<br>此外这样定义符合标准的==右手笛卡儿坐标==系统。因此将f(x, y)的原点选择在左上角数学上行得通。</p><p>取样和量化的数学术语表达：<br>令 Z 和 R 分别表示整数集和实数集。取样处理可看成是把 xy 平面分为一个网格的过程，网格中每个单元的中心的坐标是筒卡儿积 Z2中的一对元素。Z2是所有有序元素对 （Zi , Zj） 的集合, Zi,Zj是 Z 中的整数。因此，如果（x,y）是 z2 中的整数，且f是把灰度值(即实数集R中的一个实数）赋给每个特定坐标对（x,y）的一个函数。则 f(x,y) 就是一幅数字图像。</p><p>灰度值相关取值：<br>数字化过程中出于处理、存储和取样的硬件考虑，灰度值典型的取值是2的整数次幂。<br>对于一副大小为M <em> N，灰度级L = 2k的数字图像，所需存储空间为**b = M </em> N <em> k**。<br>即每个像素的灰度级为2k，则有k比特空间，共M </em> N个像素点，故所需空间b的计算如上。</p><p>图像系统的动态范围<br>定义为系统中最大可度量灰度与最小可检测灰度之比。作为一条规则，上限取决于饱和度，下限取决于噪声。</p><p>空间分辨率：<br>空间分辨率是图像中可辨别的最小细节，最通用度量为每单位距离线对数和每单位距离点数（像素数）。<br>假设我们用交替的黑色和白色垂直线来构造一幅图形，其中线宽为 W个单位 （W 可以小于 1 ）。线对的宽度就是 2W，每单位距离有 1/（2W）个线对。例如，如果一条线的宽度是 0. 1 mm，每单位距离（mm）就有5个线对。</p><p>广泛使用的图像分辨率：定义是每单位距离可分辨的最大线对数量（譬如每毫米 100 个线对）。<br>每单位距离点数：印刷和出版业中常用的图像分辨率的度量，使用每英寸点数（dpi）表示。</p><p>空间分辨率的度量必须针对空间单位来规定才有意义。图像大小本身并不会告诉我们全部内容。如果没有规定图像包含的空间维数，那么我们说一幅图像的分辨率为1024 × 1024 像索是没有意义的 。尺寸本身只是在图像容量问做比较时才有帮助。</p><p>灰度分辨率：指在灰度级中可分辨的最小变化。灰度级数通常是2的整数次幂。最通用的数是8比特。</p><h5 id="内插："><a href="#内插：" class="headerlink" title="内插："></a>内插：</h5><p>基本图像重取样方法，用已知数据来估计未知位置的数值的处理。<br>最邻近内插法：将原图像中最近邻的灰度赋给每个新位置。缺点：产生直边缘的严重失真。</p><p>双线性内插法：在该方法中，用 4 个最近邻去估计给定位置的灰度。但该方法不是一种线性内捅方法。赋值公式为：$v(x, y) ＝ αx + by+cxy ＋ d$。缺点：计算量增加。</p><p>双三次内插法：它包括 16 个最近邻点。赋值公式为：</p><p>缺点：复杂度高。优点：细节保持方面比双线性内插好。</p><h4 id="2-5像素间的一些基本关系"><a href="#2-5像素间的一些基本关系" class="headerlink" title="2.5像素间的一些基本关系"></a>2.5像素间的一些基本关系</h4><p>相邻像素：<br>位于坐标(x, y)的一个像素p有4个水平和垂直的相邻像素，即上下左右相邻四个，这个像素集称为p的4邻域。用N4（p）表示。<br>p的4个对角邻像素表示为ND（p）。<br>4邻域和对角邻域合成一起称为p的8邻域，表示为N8（p）。</p><p>令V是用于定义邻接性的灰度值集合。相关的三种类型的邻接：<br>4邻接：若q在p的4邻域中，具有V中数值的两个像素p和q是4邻接的。<br>8邻接：若q在p的8邻域中，具有V中数值的两个像素p和q是8邻接的。<br>m邻接（混合邻接）：若q在p的4邻域中，或q在p的对角邻域中，且p的4邻域和q的4邻域的交集中没有来自V中数值的像素，则具有V中数值的两个像素p和q是m邻接的。</p><p>连通性：<br>令S是图像中的一个像素子集。如果S的全部像素之间存在一个通路，则可以说两个像索 p和q在S中是连通的。对于S中的任何像素p，S中连通到该像素的像素集称为S的连通分量。如果S仅有一个连通分量，则集合S称为连通集。</p><p>区域：<br>令 R 是图像中的一个像絮子集。 如果 R 是连通集，则称 R 为一个区域。 两个区域 ． 如果它们联合形成一个连通集，则区域Ri和 Rj 称为邻接区域。不邻接的区域称为不连接区域。在谈到区域时，我们考虑的是4邻接和8邻接。为使我们的定义有意义，必须指定邻接的类型。</p><p>边界：<br>一个区域的边界是该区域中至少有一个背景邻点的像素集合。 这里再强调一下，我们必领指定用于定义邻接的连通性。上述定义也称为内边界，外边界对应于背景边界。</p><p>距离度量：<br>对于像素<strong>点p(x, y), q(s, t), z(v, w)若满足下列条件，则D为距离度量函数或度量</strong>。<br>① D(p, q) ≥ 0，【（D(p, q) = 0，当且仅当p = q】<br>② D(p, q) = D(q, p)<br>③ D(p, z) ≤ D(p, q) + D(q, z)<br>p和q间的距离：<br>欧氏距离（De）：距点(x, y)的距离小于等于某个值r的像素，是中心在(x, y)且半径为r的圆平面。<br>数学公式：<img src="https://img-blog.csdnimg.cn/b661f2cd44d54be7981ed93a2a19f0c0.png" alt="在这里插入图片描述"></p><p><strong>街区距离（D4）</strong>：距点(x, y)的街区距离小于等于某个值r的像素，是中心在(x, y)的菱形。<br>数学公式：<img src="https://img-blog.csdnimg.cn/721e10d140884857bacfb63ee4596792.png" alt="在这里插入图片描述"></p><p><strong>棋盘距离（D8）：距点(x, y)的棋盘距离小于等于某个值r的像素形成中心在(x, y)的方形。</strong><br>数学公式：<img src="https://img-blog.csdnimg.cn/9c1e8d2eb9784932bac615897bed0f92.png" alt="在这里插入图片描述"></p><h4 id="2-6数字图像处理常见的数学工具"><a href="#2-6数字图像处理常见的数学工具" class="headerlink" title="2.6数字图像处理常见的数学工具"></a>2.6数字图像处理常见的数学工具</h4><p>阵列操作：<br>阵列相<strong>乘即为图像对应矩阵表示的矩阵对应相乘</strong>，而不是矩阵相乘的运算。图像相除也意味着对应像素之间进行相除。</p><p><strong>线性操作与非线性操作</strong>：<br>线性操作指输入的和与分别对输入进行操作在求和得到的结果相同。</p><p>算数操作：<br>图像间的算术操作是阵列操作，在相应的像素对之间执行。<br>加操作是连续积分的离散形式，通过取平均可以起到降噪的目的。<br>图像相减经常用于增强图像之间的差。<br>图像相乘（或相除）的一种重要应用是阴影校正。</p><p>集合和逻辑操作<br>灰度值的并集操作和交集操作通常分别定义为相应像素对的最大和最小，而补集操作定义为常数与图像中每个像素的灰度间的两两之差。</p><p>逻辑操作：<br>处理二值图像时，OR、AND和NOT逻辑操作就是指普通的并、交和求补操作，其中“逻辑” 一词来自逻辑理论，在逻辑理论中，1代表真，0代表假。</p><p>模糊集合：理论使用隶属度函数来实现这种概念，该函数在数值1（定义为年轻）和 0（定义为非年轻）之间逐步过渡。使用模糊集合，我们可以声明一个人的年轻度为 50% （年轻和非年轻过渡的中间）。</p><p>==空间操作==：<br>①单像素操作：数字图像中执行的最简单的操作就是以灰度为基础改变单个像素的值。 这类处理可以用一个形如下式的变换函数T来描述：$s = T (z)$。 z 是原图像中像素的灰度， s 是处理后的图像中相应像素的（映射）灰度</p><p>②邻域操作：令 Sxy 代表图像 f中以任意一点（x,y）为中心的一个邻域的坐标集。领域处理在输出图像g中的相同坐标处生成一个相应的像素，该像素的值由输入图像中坐标在Sxy内的像素经指定操作决定。这种类型的处理可消除小的细节，并在图像中相应的大区域实施“斑点”补偿。<br>③几何空间变换：几何变换改进图像中像素间的空间关系。 这些变换通常称为橡皮膜变换，因为它们可看成是在一块橡皮膜上印刷一幅图像，然后根据预定的一组规则拉伸该薄膜。 在数字图像处理中，几何变换由两个基本操作组成 ： <strong>①坐标的空间变换；②灰度内插，即对空间变换后的像素赋灰皮值</strong>。坐标变换可由下式表示 ：(x, y) = T{ (v, w)) 。（v, w）是原图像中像素的坐标，（x，y）是变换后图像中像素的坐标。最常用的空间坐标变换之一是仿射变换（Wolberg[1990］）．其一般形式如下：</p><p><img src="https://img-blog.csdnimg.cn/01898ec92be74ba1bf060d62e3fe3f67.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/94f5dd8be5ca4d71a4c06e677aba947b.png" alt="在这里插入图片描述"></p><p>向量与矩阵操作：<br>多光谱图像处理是使用向盘和矩阵操作的典型领域。</p><p>图像变换：<br>变换输入图像来表达图像处理任务，在变换域执行指定的任务，之后再用反变换返回到空间域。<img src="https://img-blog.csdnimg.cn/5bc5344604b54c5cac14c96f13182223.png" alt="在这里插入图片描述"></p><p><strong>概率方法</strong><br>在开发图像处理算法中, 利用概率度量推导灰度变换算法, 使用概率和炬阵公式开发图像复原算法，用概率进行图像分割，用概率描述纹理，以概率公式为基础，导出最佳目标识别技术。</p><h4 id="2-7小结"><a href="#2-7小结" class="headerlink" title="2.7小结"></a>2.7小结</h4><p>本章内容为后续讨论提供了主要的背景知识。提供了人眼感知图像信息能力的一个基本概念。大体介绍了图像增强技术的基础，介绍的取样和内插的概念，基于像素邻域处理技术的基本组成部分等，关于图像处理的基础部分。使对数字图像处理技术的基础有了总体的认识。最后一节介绍的数字图像处理技术涉及到的数学工具，会贯穿数字图像处理的整个过程。绪论介绍的是数字图像处理的相关的整体结构，本章则是介绍了具体的数字图像处理的背景知识和涉及到的工具。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数字图像处理&quot;&gt;&lt;a href=&quot;#数字图像处理&quot; class=&quot;headerlink&quot; title=&quot;数字图像处理&quot;&gt;&lt;/a&gt;数字图像处理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;定义我们称之为图像处理领域的范围&lt;/li&gt;
&lt;li&gt;从历史观点回顾图像处理的起源&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="学习" scheme="http://michael8023.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数字图像处理" scheme="http://michael8023.github.io/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>神经网络</title>
    <link href="http://michael8023.github.io/post/13ef13e5.html"/>
    <id>http://michael8023.github.io/post/13ef13e5.html</id>
    <published>2023-07-12T06:45:02.000Z</published>
    <updated>2023-08-04T09:02:07.038Z</updated>
    
    <content type="html"><![CDATA[<iframe src='../pdf/note.pdf' width="100%" height="700px"></iframe><iframe src='../pdf/经典网络.pdf' width="100%" height="700px"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe src=&#39;../pdf/note.pdf&#39; width=&quot;100%&quot; height=&quot;700px&quot;&gt;&lt;/iframe&gt;


&lt;iframe src=&#39;../pdf/经典网络.pdf&#39; width=&quot;100%&quot; height=&quot;700px&quot;&gt;&lt;/iframe&gt;</summary>
      
    
    
    
    <category term="学习" scheme="http://michael8023.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="神经网络" scheme="http://michael8023.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>初学入门计划</title>
    <link href="http://michael8023.github.io/post/8cafc74a.html"/>
    <id>http://michael8023.github.io/post/8cafc74a.html</id>
    <published>2023-07-12T06:00:00.000Z</published>
    <updated>2023-08-04T09:01:49.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初学者入门"><a href="#初学者入门" class="headerlink" title="初学者入门"></a>初学者入门</h1><h2 id="基本理论学习"><a href="#基本理论学习" class="headerlink" title="基本理论学习"></a>基本理论学习</h2><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><p>实验室后续会批量购买，大家可以随时借阅。目前还未准备完成，因此有购书需求，组内借阅；如果没有，将书籍信息交给向尹阁豪即可。</p><ol><li>《机器学习》周志华</li><li>《统计学习方法》李航</li><li>《数字图像处理》 冈萨雷斯</li><li>《深度学习》Goodfellow</li></ol><h4 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h4><ul><li>上述书籍学习，以了解基本知识为主，重在理解每一个方法的物理意义和含义。</li></ul><h4 id="内容与时长建议"><a href="#内容与时长建议" class="headerlink" title="内容与时长建议"></a>内容与时长建议</h4><ul><li><p><strong>用时1个月</strong>，同时学习<strong>机器学习</strong>与<strong>统计学学习方法</strong>，进行互补。着重学习的章节内容应该包含但不限于：</p><ul><li><p>[x] 基本概念(《统计学习方法chapter1 统计学习及监督学习概论》)</p></li><li><p>[ ] 分类、聚类</p></li><li><p>[x] 回归</p></li><li><p>[x] [神经网络]: ./note/神经网络吴恩达</p></li></ul></li></ul><ul><li>[x] [支持向量机]: ./note/SVM.md</li></ul><ul><li><p>[ ] 贝叶斯理论</p></li><li><p>[x] [生成模型与判别模型]: ./note/生成模型与判别模型</p></li></ul><ul><li><p><strong>用时10天</strong>，<strong>数字图像处理</strong>着重学习：</p><ul><li>基本概念</li><li>基本操作：滤波、变换、直方图、卷积、形态学操作</li><li>边缘检测</li><li>图像分割</li></ul></li><li><p><strong>用时15天</strong>：结合CS231n课程，学习<strong>深度学习</strong>如下章节：</p><ul><li>基本知识</li><li>线代、概率论、数值计算</li><li>前馈网络、正则化、优化、CNN、RNN</li></ul><p>注：《深度学习》公式推导较多，晦涩难懂的部分可以先行跳过。后续对基本概念学习后再次进行复习即可。</p></li></ul><h3 id="在线课程学习"><a href="#在线课程学习" class="headerlink" title="在线课程学习"></a>在线课程学习</h3><h4 id="CS231n课程学习：用时3周"><a href="#CS231n课程学习：用时3周" class="headerlink" title="CS231n课程学习：用时3周"></a>CS231n课程学习：用时3周</h4><ul><li>官方地址 <a href="http://cs231n.stanford.edu/">http://cs231n.stanford.edu/</a></li><li>视频课程 <a href="https://www.bilibili.com/video/BV1nJ411z7fe?from=search&amp;seid=7221817427505857859">https://www.bilibili.com/video/BV1nJ411z7fe?from=search&amp;seid=7221817427505857859</a></li><li>中文笔记 <a href="https://zhuanlan.zhihu.com/p/21930884">https://zhuanlan.zhihu.com/p/21930884</a></li></ul><h4 id="机器学习课程：可以长期学习，用来扩展"><a href="#机器学习课程：可以长期学习，用来扩展" class="headerlink" title="机器学习课程：可以长期学习，用来扩展"></a>机器学习课程：可以长期学习，用来扩展</h4><ul><li>视频课程 <a href="https://www.bilibili.com/video/BV1JE411g7XF?from=search&amp;seid=17659294914585887053">https://www.bilibili.com/video/BV1JE411g7XF?from=search&amp;seid=17659294914585887053</a></li></ul><h3 id="经典论文阅读"><a href="#经典论文阅读" class="headerlink" title="经典论文阅读"></a>经典论文阅读</h3><ul><li><p>分类：AlexNet、GoogleNet、VGGNet、ResNet、DenseNet</p></li><li><p>检测：DPM、RCNN系列（RCNN、SPPNet、Fast RCNN、Faster RCNN）、YOLO、SSD、CenterNet</p></li><li><p>分割：FCN、U Net、Seg Net、DeepLab系列、PSPNet、HRNet</p></li><li><p>Transformer：ViT、PVT、Swin Transformer</p><p>上述每一个关键字都对应一篇文章，自行谷歌搜索。</p></li></ul><h2 id="编程能力"><a href="#编程能力" class="headerlink" title="编程能力"></a>编程能力</h2><ul><li>Python、Matlab</li><li>PyTorch</li><li>*MindSpore</li><li>学习VS Code，在我这里，科研代码不允许大家使用IDE进行编辑（例如PyCharm、Spider等）。Web等其他项目可以使用。</li><li>学习使用Linux，学习Shell语言。</li><li>*建议大家自行在电脑装双系统，更深层次学习Linux操作系统。</li><li>学习使用ssh连接服务器，学习Linux基本软件的使用。</li></ul><h2 id="写作能力"><a href="#写作能力" class="headerlink" title="写作能力"></a>写作能力</h2><ul><li>学习使用LaTex</li><li>其他类型工具：<ul><li>灵格斯（导入牛津字典）</li><li>Grammarly</li><li>1checker</li></ul></li></ul><h2 id="综合能力提升"><a href="#综合能力提升" class="headerlink" title="综合能力提升"></a>综合能力提升</h2><ul><li>学习使用VPN，访问Google、Google学术。</li><li>学习使用Onedirve，建议使用西工大邮箱申请教育版，1T空间。保证重要数据实时备份。</li><li>学会使用实验室Gitlab，进行代码备份，参与组内交流。</li></ul><h3 id="文献发现"><a href="#文献发现" class="headerlink" title="文献发现"></a>文献发现</h3><ul><li>学会使用Google、Google 学术、arXiv</li><li>学会在Github上实时追踪对应方向的Awesome论文合集</li><li>追踪顶会顶刊论文：<ul><li>CVPR、ICCV：<a href="https://openaccess.thecvf.com/menu">https://openaccess.thecvf.com/menu</a></li><li>ECCV：<a href="https://www.ecva.net/papers.php">https://www.ecva.net/papers.php</a></li><li>NeurIPS： <a href="https://papers.nips.cc/">https://papers.nips.cc/</a></li><li>ICLR：<a href="https://iclr.cc/">https://iclr.cc/</a></li><li>T-PAMI：<a href="https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=34">https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=34</a></li><li>IJCV：<a href="https://www.springer.com/journal/11263">https://www.springer.com/journal/11263</a></li></ul></li><li>*学会使用Mendeley归档文献</li><li>*学会使用arxiv订阅</li><li>*学会使用Reaseacher App跟踪特定关键字论文</li></ul><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><ul><li>学习Visio</li><li>学习PS基本功能</li><li>*学习Adobe Illustrator软件</li><li>画图工具 Highcharts</li><li>*学习Origin</li><li>学习Video Studio，用以制作简单视频demo</li></ul><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li>学会使用Markdown</li><li>学会使用思维导图软件，WPS自带功能（西工大有WPS会员订阅，请自行在信息中心网站查看申请方式）</li><li>*学习使用MarginNote（仅支持MacOS，iPadOS），Windows用户使用OneDrive</li><li>*学会建立个人博客，分享编程经验、学习经验。</li></ul><p><strong>注：*代表学有余力者的完成目标。但事实上，我在硕博期间都完成了*内容。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述除了基本知识部分，需要扎实地进行完成外，剩余的均可纳入综合能力范围。一个优秀的硕士、博士在毕业时需要具备以下能力：</p><ul><li>科研能力、编程能力</li><li>沟通能力（文本写作、PPT报告）</li><li>团队协作能力</li><li>社交能力</li></ul><p>科研、编程能力，决定个人的下限在哪里（能去哪种公司，能获得什么样的职位），而后三者决定自己的上限在哪里（能到到什么样的高度，做出什么样的事业）。</p><h2 id="闲谈"><a href="#闲谈" class="headerlink" title="闲谈"></a>闲谈</h2><p>从我硕士期间带学弟算起，目前毕业的有近10人。十人中，有去公司的、有去国外深造的、也有留在实验室读博的。近些年来我也在不断摸索，如何带好学生。但所有的都是双向的，需要大家配合。</p><p>我希望看到的是，师生间可以坦诚相待，我确保我可以做到这一点，也希望大家能够做到。这一点非常重要，直接关系到每个人的后续发展。</p><p>自己未来是准备科研、还是去工业界、还是去考编制，甚至是家里已经安排好了。这些我希望大家能够随时跟我商量，后续在培养上也有所侧重。当然，想法肯定是会变，但是想法的更新，之后培养的更新会有延迟。因此能够提前有所准备最好。</p><p>附带一些我这边的培养方式：</p><ol><li>直博生、博士生：以科研为主。研究课题有比较长的延续性，在可预见的范围内，3~5年的研究计划较为固定。（当然并非只能研究相关内容。如果有自己感兴趣的课题，导师评估合理后，可以展开。）此外，也需要承担少量项目课题。</li><li>硕士生（升学为主）：以科研为主。研究课题较为简单，在可预见的范围内，2~3年的研究计划较为固定。课题自行探索度高于博士生。此外，也需要承担少量项目课题。</li><li>硕士生（就业为主）：以项目课题为主。研究课题与项目内容息息相关。科研在学有余力情况下展开，一般整个硕士期间进行一个工作，能够支撑毕业论文即可。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初学者入门&quot;&gt;&lt;a href=&quot;#初学者入门&quot; class=&quot;headerlink&quot; title=&quot;初学者入门&quot;&gt;&lt;/a&gt;初学者入门&lt;/h1&gt;&lt;h2 id=&quot;基本理论学习&quot;&gt;&lt;a href=&quot;#基本理论学习&quot; class=&quot;headerlink&quot; title=&quot;基</summary>
      
    
    
    
    <category term="学习" scheme="http://michael8023.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="计算机视觉" scheme="http://michael8023.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>test1</title>
    <link href="http://michael8023.github.io/post/8ab2dce2.html"/>
    <id>http://michael8023.github.io/post/8ab2dce2.html</id>
    <published>2023-04-17T08:10:55.000Z</published>
    <updated>2023-08-01T07:53:42.105Z</updated>
    
    <content type="html"><![CDATA[<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;timeline blue&quot;&gt;&lt;div class=&#39;timeline-item headline&#39;&gt;&lt;div class=&#39;timeline-item-title&#39;&gt;&lt;div class=&#39;item-circle&#39;&gt;&lt;p&gt;时间轴样式&lt;/p&gt;
&lt;/div&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>pyqt_learning</title>
    <link href="http://michael8023.github.io/post/cba1dcbe.html"/>
    <id>http://michael8023.github.io/post/cba1dcbe.html</id>
    <published>2023-03-07T00:29:46.000Z</published>
    <updated>2023-08-04T09:03:02.627Z</updated>
    
    <content type="html"><![CDATA[<h3 id="The-first-window"><a href="#The-first-window" class="headerlink" title="The first window"></a>The first window</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication,QWidget</span><br><span class="line"><span class="comment"># 创建了一个QApplication的对象，所有程序都必须做的</span></span><br><span class="line"><span class="comment"># sys.argv指的是在运行程序时传递的参数，以列表形式返回</span></span><br><span class="line">app=QApplication(sys.argv)</span><br><span class="line"><span class="comment"># 创建了一个界面对象，小控件</span></span><br><span class="line">w=QWidget()</span><br><span class="line"><span class="comment"># 设置窗口标题</span></span><br><span class="line">w.setWindowTitle(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment"># 展示窗口</span></span><br><span class="line">w.show()</span><br><span class="line"><span class="comment"># 程序进行循环等待状态</span></span><br><span class="line">app.exec_()</span><br></pre></td></tr></table></figure><h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h3><ul><li><code>QtCore</code>：包含了核心的非GUI功能。主要和时间、文件与文件夹、各种数据、流、<code>urls</code>、mime类文件、进程与线程一起使用。</li><li><code>QtGui</code>：包含了窗口系统，事件处理、<code>2D</code>图像、基本绘画、字体和文字类。</li><li><code>QtWidgets</code>：包含了一些创建桌面应用的<code>UI</code>元素。</li><li>可以参考pyqt官方文档</li></ul><h3 id="基本UI"><a href="#基本UI" class="headerlink" title="基本UI"></a>基本<code>UI</code></h3><p>窗口内的所有控件，若想在窗口中显示，都需要表示它的父亲是谁，而不能直接用show函数显示</p><h4 id="按钮-QPushButton，位于-PyQt5-QtWidgets"><a href="#按钮-QPushButton，位于-PyQt5-QtWidgets" class="headerlink" title="按钮 QPushButton，位于 PyQt5.QtWidgets"></a>按钮 <code>QPushButton</code>，位于 <code>PyQt5.QtWidgets</code></h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication,QWidget,QPushButton</span><br><span class="line"></span><br><span class="line">app=QApplication(sys.argv)</span><br><span class="line"></span><br><span class="line">w=QWidget()</span><br><span class="line">w.setWindowTitle(<span class="string">&#x27;btn learning&#x27;</span>)</span><br><span class="line">btn=QPushButton(<span class="string">&quot;button&quot;</span>)</span><br><span class="line"><span class="comment"># 声明按钮的父元素</span></span><br><span class="line">btn.setParent(w)</span><br><span class="line"><span class="comment"># 展示窗口</span></span><br><span class="line">w.show()</span><br><span class="line"><span class="comment"># 程序进行循环等待状态</span></span><br><span class="line">app.exec_()</span><br></pre></td></tr></table></figure><h4 id="文本-QLabel"><a href="#文本-QLabel" class="headerlink" title="文本 QLabel"></a>文本 <code>QLabel</code></h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication,QWidget,QPushButton,QLabel</span><br><span class="line">app=QApplication(sys.argv)</span><br><span class="line">w=QWidget()</span><br><span class="line">w.setWindowTitle(<span class="string">&#x27;label learning&#x27;</span>)</span><br><span class="line">label=QLabel(<span class="string">&#x27;账号：&#x27;</span>,w)</span><br><span class="line"><span class="comment"># 显示位置与大小:x,y,w,h</span></span><br><span class="line"><span class="comment"># 显示位置指的是在父元素内的元素位置</span></span><br><span class="line">label.setGeometry(<span class="number">20</span>,<span class="number">20</span>,<span class="number">300</span>,<span class="number">30</span>)</span><br><span class="line"><span class="comment"># 展示窗口</span></span><br><span class="line">w.show()</span><br><span class="line"><span class="comment"># 程序进行循环等待状态</span></span><br><span class="line">app.exec_()</span><br></pre></td></tr></table></figure><h4 id="输入框-QlineEdit"><a href="#输入框-QlineEdit" class="headerlink" title="输入框 QlineEdit"></a>输入框 <code>QlineEdit</code></h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication,QWidget,QPushButton,QLabel,QLineEdit</span><br><span class="line"><span class="comment"># import PyQt5.QtWidgets</span></span><br><span class="line">app=QApplication(sys.argv)</span><br><span class="line">w=QWidget()</span><br><span class="line">w.setWindowTitle(<span class="string">&#x27;lineEdit learning&#x27;</span>)</span><br><span class="line"></span><br><span class="line">label=QLabel(<span class="string">&#x27;账号：&#x27;</span>,w)</span><br><span class="line">label.setGeometry(<span class="number">20</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">edit=QLineEdit(w)</span><br><span class="line">edit.setGeometry(<span class="number">55</span>,<span class="number">20</span>,<span class="number">200</span>,<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">btn=QPushButton(<span class="string">&#x27;提交&#x27;</span>,w)</span><br><span class="line">btn.setGeometry(<span class="number">260</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示窗口</span></span><br><span class="line">w.show()</span><br><span class="line"><span class="comment"># 程序进行循环等待状态</span></span><br><span class="line">app.exec_()</span><br></pre></td></tr></table></figure><h4 id="窗口大小、位置"><a href="#窗口大小、位置" class="headerlink" title="窗口大小、位置"></a>窗口大小、位置</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调整窗口的大小</span></span><br><span class="line">w.resize(<span class="number">300</span>,<span class="number">300</span>)</span><br><span class="line"><span class="comment"># 将窗口移动在桌面的左上角</span></span><br><span class="line">w.move(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication,QWidget,QPushButton,QLabel,QLineEdit,QDesktopWidget</span><br><span class="line"><span class="comment"># import PyQt5.QtWidgets</span></span><br><span class="line">app=QApplication(sys.argv)</span><br><span class="line">w=QWidget()</span><br><span class="line">w.setWindowTitle(<span class="string">&#x27;label learning&#x27;</span>)</span><br><span class="line">label=QLabel(<span class="string">&#x27;账号：&#x27;</span>,w)</span><br><span class="line">label.setGeometry(<span class="number">20</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">edit=QLineEdit(w)</span><br><span class="line">edit.setGeometry(<span class="number">55</span>,<span class="number">20</span>,<span class="number">200</span>,<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">btn=QPushButton(<span class="string">&#x27;提交&#x27;</span>,w)</span><br><span class="line">btn.setGeometry(<span class="number">50</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整窗口的大小</span></span><br><span class="line">w.resize(<span class="number">300</span>,<span class="number">300</span>)</span><br><span class="line"><span class="comment"># 将窗口移动到某一个位置</span></span><br><span class="line"><span class="comment"># w.move(100,100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将窗口移动到中心位置</span></span><br><span class="line">pointer_center=QDesktopWidget().availableGeometry().center()</span><br><span class="line">center_x=pointer_center.x()</span><br><span class="line">center_y=pointer_center.y()</span><br><span class="line">old_x,old_y,width,height=w.frameGeometry().getRect()</span><br><span class="line">w.move(center_x-width/<span class="number">2</span>,center_y-height/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示窗口</span></span><br><span class="line">w.show()</span><br><span class="line"><span class="comment"># 程序进行循环等待状态</span></span><br><span class="line">app.exec_()</span><br></pre></td></tr></table></figure><p>获取屏幕中心位置坐标<code>pointer_center=QDesktopWidget().availableGeometry().center()</code></p><p>获取窗口的位置以及边长信息</p><p><code>old_x,old_y,width,height=w.frameGeometry().getRect()</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;The-first-window&quot;&gt;&lt;a href=&quot;#The-first-window&quot; class=&quot;headerlink&quot; title=&quot;The first window&quot;&gt;&lt;/a&gt;The first window&lt;/h3&gt;&lt;figure class=&quot;hi</summary>
      
    
    
    
    <category term="学习" scheme="http://michael8023.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="UI" scheme="http://michael8023.github.io/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫(持续更新)</title>
    <link href="http://michael8023.github.io/post/db306517.html"/>
    <id>http://michael8023.github.io/post/db306517.html</id>
    <published>2023-02-02T09:12:18.000Z</published>
    <updated>2023-08-04T09:03:01.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python爬虫（持续更新）"><a href="#python爬虫（持续更新）" class="headerlink" title="python爬虫（持续更新）"></a>python爬虫（持续更新）</h1><blockquote><h5 id="什么是爬虫"><a href="#什么是爬虫" class="headerlink" title="什么是爬虫"></a>什么是爬虫</h5><p>-通过编写程序，==模拟==浏览器上网，然后让其去互联网上==抓取==数据的过程。（可以抓取全部数据，也可以抓取符合条件的数据）</p><h4 id="爬虫的价值"><a href="#爬虫的价值" class="headerlink" title="爬虫的价值"></a>爬虫的价值</h4><p>获取数据，以及把爬取的数据商业化，产品化</p><h4 id="爬虫的合法性"><a href="#爬虫的合法性" class="headerlink" title="爬虫的合法性"></a>爬虫的合法性</h4><p>-在法律中不被禁止</p><p>-具有违法风险</p><p>-善意爬虫 恶意爬虫</p><h4 id="如何合法爬虫"><a href="#如何合法爬虫" class="headerlink" title="如何合法爬虫"></a>如何合法爬虫</h4><p>-时常优化程序</p><p>-注意审查</p><h4 id="爬虫在使用场景中的分类"><a href="#爬虫在使用场景中的分类" class="headerlink" title="爬虫在使用场景中的分类"></a>爬虫在使用场景中的分类</h4><p>-通用爬虫：抓取系统的重要组成部分。抓取的是一整张页面数据</p><p>-聚焦爬虫：是建立在通用爬虫的基础之上。抓取的是页面中特定的内容。</p><p>-增量式爬虫：检测网站中数据更新的情况。只会抓取网站中最新更新的数据。</p><h4 id="反爬机制"><a href="#反爬机制" class="headerlink" title="反爬机制"></a>反爬机制</h4><p>​    门户网站，可以制定相关的策略和技术手段，防止爬虫程序进行网站数据的获取</p><h4 id="反反爬策略"><a href="#反反爬策略" class="headerlink" title="反反爬策略"></a>反反爬策略</h4><p>​    爬虫程序可以通过指定相关的策略或者技术手段，破解门户网站中具备的反爬机制，从而可以获取门户网站的数据。</p><p>$robots.txt$协议：君子协议，规定了网站中哪些数据可以被爬虫爬取，哪些不可以。</p><h4 id="http-协议"><a href="#http-协议" class="headerlink" title="$http$协议"></a>$http$协议</h4><p>​    -概念：就是服务器和客户端进行数据交互的一种形式。</p><h4 id="常用请求头信息"><a href="#常用请求头信息" class="headerlink" title="常用请求头信息"></a>常用请求头信息</h4><p>​    -User-Agent:请求载体的身份标识</p><p>​    -Connection：请求完毕后是断开连接还是保持连接</p><h4 id="常用的响应头信息："><a href="#常用的响应头信息：" class="headerlink" title="常用的响应头信息："></a>常用的响应头信息：</h4><p>​    -Connect-Type：服务器响应回客户端的数据类型</p><h4 id="https-协议："><a href="#https-协议：" class="headerlink" title="$https$协议："></a>$https$协议：</h4><p>​    -表示安全的$http$协议（数据加密）</p><h4 id="加密方式-："><a href="#加密方式-：" class="headerlink" title="加密方式 ："></a>加密方式 ：</h4><p>​    -对称密钥加密 ：客户端指定密钥，发送到服务器端之后进行解密。</p><p>​    -非对称密钥加密：服务器端发送公钥，之后再用服务器的私钥进行解密。效率低，公钥篡改。</p><p>​    -证书密钥加密：服务器端把公钥提交到证书认证机构，审核之后会将公钥提供数字签名（防伪），之后发送到客户端，客户端就会通过公钥对报文进行加密发送。 </p></blockquote><h2 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h2><blockquote><p>-<code>urllib</code>模块</p><p>-request模块:python中原生的一款基于网络请求的模块，功能强大，简单便捷，效率高。</p><p>==作用：模拟浏览器发请求==</p></blockquote><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><ul><li>指定<code>url</code></li><li>发起请求</li><li>获取响应数据</li><li>持久化存储 </li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#需求：爬取搜狗首页的页面数据</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;requests第一血&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#指定url</span></span><br><span class="line">url=<span class="string">&#x27;https://www.sogou.com/&#x27;</span></span><br><span class="line"><span class="comment">#发起请求</span></span><br><span class="line"><span class="comment">#get方法会返回一个响应对象</span></span><br><span class="line">response=requests.get(url=url)</span><br><span class="line"><span class="comment">#获取响应数据.text返回的是字符串形式的响应数据</span></span><br><span class="line">page_text=response.text</span><br><span class="line"><span class="built_in">print</span>(page_text)</span><br><span class="line"><span class="comment">#持久化存储</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./sogou.html&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    fp.write(page_text)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;爬取数据结束&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="实战巩固"><a href="#实战巩固" class="headerlink" title="实战巩固"></a>实战巩固</h3><p>User-Agent(请求载体的身份标识)</p><p><code>UA</code>检测：门户网站的服务器会监测对应请求的载体身份标识，如果检测到<code>UA</code>是某一款浏览器，则说明该请求为正常请求，但是如果监测到请求的<code>UA</code>不是基于某一款浏览器的，则表示该请求为不正常的请求（爬虫）</p><p>==$UA伪装是一种反反爬策略$==，让爬虫对应的请求载体身份标识伪装成某一款浏览器。将对应的User-Agent封装到一个字典中</p><h4 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h4><ul><li>爬取搜狗指定词条的搜索结果页面（简易网页采集器）</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="comment"># ==$UA伪装是一种反反爬策略$==，让爬虫对应的请求载体身份标识伪装成某一款浏览器。将对应的User-Agent封装到一个字典中</span></span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36 Edg/109.0.1518.61&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">url=<span class="string">&#x27;https://www.sogou.com/web&#x27;</span></span><br><span class="line"><span class="comment">#处理url携带的参数：封装到字典中</span></span><br><span class="line">kw=<span class="built_in">input</span>(<span class="string">&#x27;enter a word:&#x27;</span>)</span><br><span class="line">param=&#123;</span><br><span class="line">    <span class="string">&#x27;query&#x27;</span>:kw</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># `UA`检测：门户网站的服务器会监测对应请求的载体身份标识，如果检测到`UA`是某一款浏览器，</span></span><br><span class="line"><span class="comment"># 则说明该请求为正常请求，但是如果监测到请求的`UA`不是基于某一款浏览器的，则表示该请求为</span></span><br><span class="line"><span class="comment"># 不正常的请求（爬虫）</span></span><br><span class="line"><span class="comment">#对指定的url发起的请求对应的url是携带参数的，并且请求过程中处理了参数</span></span><br><span class="line">response=requests.get(url=url,params=param,headers=headers)</span><br><span class="line">page_text=response.text</span><br><span class="line">fileName=kw+<span class="string">&#x27;.html&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(fileName,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> rf:</span><br><span class="line">    rf.write(page_text)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;网页已爬取成功&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>破解百度翻译</p><ul><li>对应的请求是post请求（携带了参数）</li><li>响应数据是一组<code>json</code>数据（从响应头信息中可以得到）</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment">#指定url</span></span><br><span class="line">post_url=<span class="string">&#x27;https://fanyi.baidu.com/sug&#x27;</span></span><br><span class="line"><span class="comment">#进行UA伪装</span></span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36 Edg/109.0.1518.69&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">word=<span class="built_in">input</span>(<span class="string">&#x27;enter a word:&#x27;</span>)</span><br><span class="line"><span class="comment">#post请求参数处理</span></span><br><span class="line">data=&#123;</span><br><span class="line">    <span class="string">&#x27;kw&#x27;</span>:word</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#请求发送</span></span><br><span class="line">response=requests.post(url=post_url,data=data,headers=headers)</span><br><span class="line"><span class="comment">#获取响应数据:json()方法返回的是一个obj（如果确认服务器响应数据是json类型的才可以使用json方法进行对象返回）</span></span><br><span class="line">dic_obj=response.json().get(<span class="string">&#x27;data&#x27;</span>)[<span class="number">0</span>].get(<span class="string">&#x27;v&#x27;</span>)</span><br><span class="line"><span class="comment">#进行持久化存储</span></span><br><span class="line">fileName=word+<span class="string">&#x27;.json&#x27;</span></span><br><span class="line">fp=<span class="built_in">open</span>(fileName,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">json.dump(dic_obj,fp=fp,ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">fp.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;over&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>​    -<code>UA</code>检测</p><p>​    -<code>UA</code>伪装</p><p><code>Ajax请求</code></p><p>在不使用数据解析的情况下拿取一部分数据</p><ul><li>爬取豆瓣电影分类排行榜</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment">#指定url</span></span><br><span class="line">url=<span class="string">&#x27;https://movie.douban.com/j/chart/top_list?&#x27;</span></span><br><span class="line"><span class="comment">#进行UA伪装</span></span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36 Edg/109.0.1518.69&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>:<span class="string">&#x27;BAIDUID=09627493A5E3B931AE4E43DC8445511E:FG=1; APPGUIDE_10_0_2=1; REALTIME_TRANS_SWITCH=1; FANYI_WORD_SWITCH=1; HISTORY_SWITCH=1; SOUND_SPD_SWITCH=1; SOUND_PREFER_SWITCH=1; BIDUPSID=09627493A5E3B931AE4E43DC8445511E; PSTM=1674878527; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; Hm_lvt_64ecd82404c51e03dc91cb9e8c025574=1674877358,1674879962; H_PS_PSSID=36542_36920_37989_37802_37934_26350_37958_37881; BA_HECTOR=ah0k2g202024a001818l80i81ht99c71k; delPer=0; PSINO=1; ZFY=y:Ataojx0TXrx8bgzGs9gTBlGrqCpf:BvSGHSKWbfGnT4:C; BAIDUID_BFESS=09627493A5E3B931AE4E43DC8445511E:FG=1; Hm_lpvt_64ecd82404c51e03dc91cb9e8c025574=1674881648; ab_sr=1.0.1_MWUxMzk3YTU2N2RlNjI5YjJmNzA4YWFhN2YzMTc1MjVlODhhOWI5ZjkwMDQ5NGVlYjA4NTBiMjE2ZDNjMGI1NGYxNTA4M2FmMWYzYjU0NmM2MzQ0ZGYwZTlmYjdmOTY0MDAyNzU3YTk3ZDlhZTExMWJiMTllZmEzMDVhMWU0NTE4NjU0NDEzY2JjODQ3OWY4YTM2MTdiMzVkNGNlMmY2ZA==&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#get请求参数处理</span></span><br><span class="line">param=&#123;</span><br><span class="line">    <span class="string">&#x27;type&#x27;</span>:<span class="string">&#x27;24&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;interval_id&#x27;</span>:<span class="string">&#x27;100:90&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;action&#x27;</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;start&#x27;</span>:<span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;limit&#x27;</span>:<span class="string">&#x27;20&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#请求发送</span></span><br><span class="line">response=requests.get(url=url,params=param,headers=headers)</span><br><span class="line"><span class="comment">#获取响应数据:json()方法返回的是一个obj（如果确认服务器响应数据是json类型的才可以使用json方法进行对象返回）</span></span><br><span class="line">list_data=response.json()</span><br><span class="line"><span class="comment"># with open(&#x27;./douban.json&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as rf:</span></span><br><span class="line"><span class="comment">#     rf.write(json.dumps(list_data,ensure_ascii=False))</span></span><br><span class="line"></span><br><span class="line">rf=<span class="built_in">open</span>(<span class="string">&#x27;./douban.json&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">json.dump(list_data,fp=rf,ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;over!&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ajax请求</code>，当滚轮拖动到底部时会发起一组<code>ajax</code></p><ul><li>爬取肯德基餐厅位置信息</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line">post_url=<span class="string">&#x27;http://www.kfc.com.cn/kfccda/ashx/GetStoreList.ashx?op=keyword&#x27;</span></span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>:<span class="string">&#x27;route-cell=ksa; ASP.NET_SessionId=kjawudawk1yoe2trozw3tgtb; Hm_lvt_1039f1218e57655b6677f30913227148=1674891252; Hm_lpvt_1039f1218e57655b6677f30913227148=1674891252; SERVERID=db2965ac6d1d4f093009cf9d5cafcc6f|1674891431|1674891251&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">kw=<span class="built_in">input</span>(<span class="string">&#x27;输入地址进行查询：&#x27;</span>)</span><br><span class="line">data=&#123;</span><br><span class="line">    <span class="string">&#x27;cname&#x27;</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;pid&#x27;</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;keyword&#x27;</span>:kw,</span><br><span class="line">    <span class="string">&#x27;pageIndex&#x27;</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;pageSize&#x27;</span>:<span class="string">&#x27;10&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">response=requests.post(post_url,data=data,headers=headers)</span><br><span class="line">dic_obj=response.text</span><br><span class="line">fileName=kw+<span class="string">&#x27;周边的餐厅.html&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(fileName,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    fp.write(dic_obj)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;over!&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>爬取国家药品监督总局中基于中华人民共和国化妆品生产许可证相关数据</li></ul><blockquote><p>很有可能存在有动态加载出来的数据</p><p>-通过对详情页url的观察发现：</p><p>​    -url的域名都是一样的，只有携带的参数（id）不一样</p><p>​    -id值可以从首页对应的<code>AJAX</code>请求到的json串中获取</p><p>​    -域名和id值拼接出一个完整的企业对应的详情页的url </p></blockquote><h1 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h1><p>聚焦爬虫：爬取页面中指定的页面内容。</p><p>聚焦爬虫编码流程：</p><ul><li>指定url</li><li>发起请求</li><li>获取响应数据</li><li>==数据解析==</li><li>持久化存储</li></ul><blockquote><p>建立在通用爬虫基础之上的，通过爬虫获取数据进行数据解析</p></blockquote><p>数据解析分类：</p><ul><li>正则</li><li><code>bs4</code></li><li><code>xpath</code>（重点）</li></ul><p>数据解析原理概述：</p><ul><li>解析的局部文本内容会在标签之间或者标签对应的属性中进行存</li></ul><ol><li>进行==指定标签的定位==</li><li>标签或者==标签对应的属性中存储的数据值进行提取（解析）==</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#需求：爬取图片数据</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&#x27;https://img1.baidu.com/it/u=2836049642,785082450&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=268&amp;h=74&#x27;</span></span><br><span class="line"><span class="comment">#content返回的是二进制形式的图片数据</span></span><br><span class="line"><span class="comment">#text（）返回字符串形式图片数据   content（二进制） json（队形）</span></span><br><span class="line">img_data=requests.get(url=url).content</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./qiutu.jpg&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    fp.write(img_data)</span><br></pre></td></tr></table></figure><h3 id="正则解析"><a href="#正则解析" class="headerlink" title="正则解析"></a>正则解析</h3><p><img src="C:\Users\11147\AppData\Roaming\Typora\typora-user-images\image-20230130135858208.png" alt="image-20230130135858208" style="zoom:50%;" /></p><p>需求：爬取糗事百科中糗图</p><p>分析：</p><ul><li>查看elements ，定位图片所在的<code>img</code>标签</li></ul><blockquote><p>由于糗事百科官网停服，需求更为==抓取百度图片==</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#需求：爬取图片数据</span></span><br><span class="line"><span class="comment">#搜索关键词，自动抓取五张百度图片储存到本地</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">url=<span class="string">&#x27;https://image.baidu.com/search/acjson?&#x27;</span></span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>:<span class="string">&#x27;winWH=%5E6_1588x949; BDIMGISLOGIN=0; BDqhfp=%E7%B3%97%E4%BA%8B%E7%99%BE%E7%A7%91%26%26NaN-1undefined%26%268567%26%2615; BAIDUID=09627493A5E3B931AE4E43DC8445511E:FG=1; BIDUPSID=09627493A5E3B931AE4E43DC8445511E; PSTM=1674878527; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; BA_HECTOR=84018kal8hag042h84248gqa1htbpas1l; ZFY=y:Ataojx0TXrx8bgzGs9gTBlGrqCpf:BvSGHSKWbfGnT4:C; BAIDUID_BFESS=09627493A5E3B931AE4E43DC8445511E:FG=1; H_PS_PSSID=36542_37989_37802_37934_26350_37958_37881; PSINO=1; delPer=0; BDRCVFR[dG2JNJb_ajR]=mk3SLVN4HKm; userFrom=www.baidu.com; BDRCVFR[-pGxjrCMryR]=mk3SLVN4HKm; BDRCVFR[tox4WRQ4-Km]=mk3SLVN4HKm; ab_sr=1.0.1_MzBlNTMxNDkwMjg0MzMxMDg2ZjRhNzQ3ZGY3Yjg3MmQzOGVmNjU0YjI4N2IxYWJkZDVlMDgzNDhlOWUzYTMwYzc2NjE4YjVmZjMwNjQwOGE0NWRhNjRkNTVmYjA4OTYxYzJiMzVkODY2ZjM0ZTY0NDRjMzI1ZjcyZjMzMWYxODYyOWE2ZjQ4OWFhNzZmZjFiOWQxMmE5YTMwM2ZkNmQyOA==&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">word=<span class="built_in">input</span>(<span class="string">&quot;enter a word:&quot;</span>)</span><br><span class="line">param=&#123;</span><br><span class="line">    <span class="string">&#x27;tn&#x27;</span>:<span class="string">&#x27;resultjson_com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;logid&#x27;</span>:<span class="string">&#x27;9182991455067073803&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ipn&#x27;</span>:<span class="string">&#x27;rj&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ct&#x27;</span>:<span class="string">&#x27;201326592&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;fp&#x27;</span>:<span class="string">&#x27;result&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;word&#x27;</span>:word,</span><br><span class="line">    <span class="string">&#x27;queryWord&#x27;</span>:word,</span><br><span class="line">    <span class="string">&#x27;cl&#x27;</span>:<span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;lm&#x27;</span>:<span class="string">&#x27;-1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ie&#x27;</span>:<span class="string">&#x27;utf-8&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;oe&#x27;</span>:<span class="string">&#x27;utf-8&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;nc&#x27;</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;pn&#x27;</span>:<span class="string">&#x27;390&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;rn&#x27;</span>:<span class="string">&#x27;30&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;gsm&#x27;</span>:<span class="string">&#x27;186&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">response=requests.get(url=url,params=param,headers=headers).text</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用聚焦爬虫对图片信息进行提取 </span></span><br><span class="line">ex=<span class="string">&#x27;&quot;thumbURL&quot;:&quot;(.*?)&quot;&#x27;</span></span><br><span class="line"><span class="comment">#re.S 即为 . 并且包括换行符在内的任意字符（. 不包括换行符）</span></span><br><span class="line">res=re.findall(ex,response，re.S)</span><br><span class="line">os.mkdir(word)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    img_data=requests.get(url=res[i]).content</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./&#x27;</span>+word+<span class="string">&#x27;./&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27;.jpg&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(img_data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;over!&quot;</span>)</span><br></pre></td></tr></table></figure><p>如何获取图片名称（包含图片后缀）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#src为图片对应网址</span></span><br><span class="line">img_name=src.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line"><span class="comment">#图片存储的路径</span></span><br><span class="line">img_path=<span class="string">&#x27;./qiutuLibs/&#x27;</span>+img_name</span><br></pre></td></tr></table></figure><p>如何分页爬取</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置一个通用的url模板</span></span><br><span class="line">url=<span class="string">&#x27;.....%d.....&#x27;</span></span><br><span class="line"><span class="keyword">for</span> pageNum <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>):</span><br><span class="line">    new_url=<span class="built_in">format</span>(url%pageNum)</span><br></pre></td></tr></table></figure><h3 id="bs4解析"><a href="#bs4解析" class="headerlink" title="bs4解析"></a><code>bs4</code>解析</h3><p>bs4是python独有的解析方式 </p><p>原理：</p><ol><li>实例化一个<code>BeautifulSoup</code>对象，并且将页面源码加载到该对象中</li><li>通过调用<code>BeautifulSoup</code>对象中==相关的属性或者方法==进行标签定位和数据提取</li></ol><p>环境安装：<code>pip install bs4</code> <code>pip install lxml</code></p><p> 如何实例化<code>BeautifulSoup</code>对象：</p><ul><li>将本地的html文档中的而数据加载到该对象中</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="comment">#实例化对象</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./cupfox.html&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    soup=BeautifulSoup(fp,<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(soup)</span><br></pre></td></tr></table></figure><ul><li>将互联网上获取的页面源码加载到该对象中</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&#x27;https://cupfox.app/&#x27;</span></span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>:<span class="string">&#x27;winWH=%5E6_1588x949; BDIMGISLOGIN=0; BDqhfp=%E7%B3%97%E4%BA%8B%E7%99%BE%E7%A7%91%26%26NaN-1undefined%26%268567%26%2615; BAIDUID=09627493A5E3B931AE4E43DC8445511E:FG=1; BIDUPSID=09627493A5E3B931AE4E43DC8445511E; PSTM=1674878527; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; BA_HECTOR=84018kal8hag042h84248gqa1htbpas1l; ZFY=y:Ataojx0TXrx8bgzGs9gTBlGrqCpf:BvSGHSKWbfGnT4:C; BAIDUID_BFESS=09627493A5E3B931AE4E43DC8445511E:FG=1; H_PS_PSSID=36542_37989_37802_37934_26350_37958_37881; PSINO=1; delPer=0; BDRCVFR[dG2JNJb_ajR]=mk3SLVN4HKm; userFrom=www.baidu.com; BDRCVFR[-pGxjrCMryR]=mk3SLVN4HKm; BDRCVFR[tox4WRQ4-Km]=mk3SLVN4HKm; ab_sr=1.0.1_MzBlNTMxNDkwMjg0MzMxMDg2ZjRhNzQ3ZGY3Yjg3MmQzOGVmNjU0YjI4N2IxYWJkZDVlMDgzNDhlOWUzYTMwYzc2NjE4YjVmZjMwNjQwOGE0NWRhNjRkNTVmYjA4OTYxYzJiMzVkODY2ZjM0ZTY0NDRjMzI1ZjcyZjMzMWYxODYyOWE2ZjQ4OWFhNzZmZjFiOWQxMmE5YTMwM2ZkNmQyOA==&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">response=requests.get(url=url,headers=headers).text</span><br><span class="line">soup=BeautifulSoup(response,<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(soup)</span><br></pre></td></tr></table></figure><p>提供的用于数据解析的方法和属性：</p><ul><li><p><code>soup.tagName</code>：返回的是文档中第一次出现的<code>tagName</code>标签</p></li><li><p><code>soup.find()</code>： 可以用来寻找<code>tagName</code>标签；可以进行属性定位（根据具体的属性来定位对应标签）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#寻找class为song的div标签，但同样只能定位第一个</span></span><br><span class="line"><span class="built_in">print</span>(soup.find(<span class="string">&#x27;div&#x27;</span>,class_=<span class="string">&#x27;song&#x27;</span>))<span class="comment">#注意class_，其他属性不用加_</span></span><br></pre></td></tr></table></figure></li><li><p><code>soup.find_all()</code>：基本用法和<code>find</code>相似，但是<code>find_all</code>可以定位所有符合条件的标签，以==列表==格式返回</p></li><li><p><code>soup.select(&#39;某种选择器&#39;)</code>：选择器，可以使用类选择器（.），标签选择器，id选择器(#)，返回的是一个列表</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.select(<span class="string">&#x27;#hongchen&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p><code>soup.select(&#39;某种选择器&#39;)</code>：可以使用在层级选择器，用==&gt;==作为层级分隔符</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pprint.pprint(soup.select(<span class="string">&#x27;.song &gt; a&#x27;</span>))</span><br></pre></td></tr></table></figure><hr><p>2023.3.1</p></li></ul><h4 id="bs4实战-爬取三国演义的标题和各个章节内容"><a href="#bs4实战-爬取三国演义的标题和各个章节内容" class="headerlink" title="bs4实战-爬取三国演义的标题和各个章节内容"></a><code>bs4</code>实战-爬取三国演义的标题和各个章节内容</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="comment"># 对首页的页面数据进行爬取</span></span><br><span class="line">url=<span class="string">&#x27;http://www.shicimingju.com/book/sanguoyanyi.html&#x27;</span></span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">page_text=requests.get(url=url,headers=headers)</span><br><span class="line"><span class="comment"># 解决乱码问题</span></span><br><span class="line">page_text.encoding=<span class="string">&#x27;GBK&#x27;</span></span><br><span class="line">page_text.encoding=<span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"></span><br><span class="line">page_text=page_text.text</span><br><span class="line"><span class="comment"># 在首页中解析出章节的标题和详情页的url</span></span><br><span class="line">    <span class="comment"># 实例化beautifulsoup对象，需要将页面源码数据加载到该对象中</span></span><br><span class="line">soup=BeautifulSoup(page_text,<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析章节标题和详情页数据</span></span><br><span class="line">li_list=soup.select(<span class="string">&#x27;.book-mulu &gt; ul &gt; li&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fp=<span class="built_in">open</span>(<span class="string">&#x27;./sanguo.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">    <span class="comment">#li.a指的是a标签里面的内容</span></span><br><span class="line">    title=li.a.string</span><br><span class="line">    detail_url=<span class="string">&#x27;http://www.shicimingju.com&#x27;</span>+li.a[<span class="string">&#x27;href&#x27;</span>]</span><br><span class="line">    <span class="comment"># 对详情页发起请求，解析 出章节内容</span></span><br><span class="line">    detail_page=requests.get(url=detail_url,headers=headers)</span><br><span class="line">    detail_page.encoding=<span class="string">&#x27;gbk&#x27;</span></span><br><span class="line">    detail_page.encoding=<span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">    detail_page_text=detail_page.text</span><br><span class="line">    <span class="comment"># 解析出详情页中相关的数据内容</span></span><br><span class="line">    detail_soup=BeautifulSoup(detail_page_text,<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    div_tag=detail_soup.find(<span class="string">&#x27;div&#x27;</span>,class_=<span class="string">&#x27;chapter_content&#x27;</span>)</span><br><span class="line">    <span class="comment"># 解析到了章节内容</span></span><br><span class="line">    content=div_tag.text</span><br><span class="line">    fp.write(title+<span class="string">&#x27;:&#x27;</span>+content+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(title,<span class="string">&#x27;爬取成功&#x27;</span>)</span><br><span class="line">fp.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="xpath解析：最常用且最便捷高效的解析方式。通用性"><a href="#xpath解析：最常用且最便捷高效的解析方式。通用性" class="headerlink" title="xpath解析：最常用且最便捷高效的解析方式。通用性"></a><code>xpath</code>解析：最常用且最便捷高效的解析方式。通用性</h3><p>-xpath解析原理：</p><ol><li>实例化一个etree的对象，且需要将被解析的页面源码数据加载到该对象中</li><li>调用etree对象中的xpath方法结合着xpath方法结合着xpath表达式实现标签的定位和内容的捕获。</li><li>环境的安装：pip install <code>lxml</code></li></ol><p>如何实例化一个<code>etree</code>对象：<code>from lxml import etree</code></p><ul><li>将本地的html文档中的源码数据加载到<code>etree</code>对象中：<code>etree.parse(filePath)</code></li><li>可以将从互联网上获取的源码数据加载到该对象中：<code>etree.HTML(&#39;page_text&#39;)&#39;</code></li></ul><h4 id="xpath-‘xpath表达式’"><a href="#xpath-‘xpath表达式’" class="headerlink" title="xpath(‘xpath表达式’)"></a><code>xpath</code>(‘xpath表达式’)</h4><p>只能进行层级定位</p><p>/：表示的是从根目录开始进行的定位，或者一个/表示一个层级。</p><p>//：表示的是多个层级 。可以从任意的位置去定位标签，找到所有的标签</p><p>属性定位：<code>//div[@class=&#39;song&#39;]</code>即为<code>tag[@attrName=&quot;attrValue&quot;]</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定位类名为song的div标签位置</span></span><br><span class="line">r=tree.xpath(<span class="string">&#x27;//div[@class=&quot;song&quot;]&#x27;</span>)</span><br></pre></td></tr></table></figure><p>索引定位：在标签名的后面加上中括号写上索引值==索引是从1开始的而不是0==</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r=tree.xpath(<span class="string">&#x27;//div[@class=&quot;song&quot;]/p[3]&#x27;</span>)</span><br></pre></td></tr></table></figure><p>取文本：</p><ul><li><p>在所定位的标签后面加上一个<code>/text()</code>就能够取到标签里的对应内容（直系内容）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r=tree.xpath(<span class="string">&#x27;//div[@class=&quot;song&quot;][2]/a/text()&#x27;</span>)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li><li><p>如果想直接获取标签的子标签里面的文本数据。只需要把 <code>/text()</code>改为 <code>//text()</code>即可(非直系的文本内容)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r=tree.xpath(<span class="string">&#x27;//div[@class=&quot;song&quot;][2]//text()&#x27;</span>)[<span class="number">5</span>]</span><br></pre></td></tr></table></figure></li></ul><p>取属性：直接在定位标签后面加上/@attrName</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r=tree.xpath(<span class="string">&#x27;//div[@class=&quot;song&quot;][2]/a/@href&#x27;</span>)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h5 id="xpath课程笔记"><a href="#xpath课程笔记" class="headerlink" title="xpath课程笔记"></a>xpath课程笔记</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="comment">#实例化一个etree对象，且将被解析的源码加载到该对象中</span></span><br><span class="line"><span class="comment"># parser=etree.HTMLParser(encoding=&#x27;utf-8&#x27;)</span></span><br><span class="line">tree=etree.parse(<span class="string">&#x27;vim.html&#x27;</span>,etree.HTMLParser())</span><br><span class="line"><span class="comment">#xpath表达式进行的定位</span></span><br><span class="line"><span class="comment"># r=tree.xpath(&#x27;/html/body/div&#x27;)#最前面的那个/表示是根节点,寻找路径</span></span><br><span class="line"><span class="comment"># r=tree.xpath(&#x27;/html//div&#x27;)#//表示的是多个层级，相当于bs4中的空格</span></span><br><span class="line"><span class="comment"># r=tree.xpath(&#x27;//div&#x27;)</span></span><br><span class="line"><span class="comment"># r=tree.xpath(&#x27;//div[@class=&quot;song&quot;]/p[3]&#x27;)</span></span><br><span class="line">r=tree.xpath(<span class="string">&#x27;//div[@class=&quot;song&quot;][2]/a/@href&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 用来引用本地的图片 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ![background](../img/postImg/1.jpg) --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../img/postImg/background.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;background&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:67%;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python爬虫（持续更新）&quot;&gt;&lt;a href=&quot;#python爬虫（持续更新）&quot; class=&quot;headerlink&quot; title=&quot;python爬虫（持续更新）&quot;&gt;&lt;/a&gt;python爬虫（持续更新）&lt;/h1&gt;&lt;blockquote&gt;
&lt;h5 id=&quot;什么是爬</summary>
      
    
    
    
    <category term="学习" scheme="http://michael8023.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="python" scheme="http://michael8023.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ChangeMyMind</title>
    <link href="http://michael8023.github.io/post/a7c623a1.html"/>
    <id>http://michael8023.github.io/post/a7c623a1.html</id>
    <published>2022-11-13T12:55:22.000Z</published>
    <updated>2023-08-04T11:55:31.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="改变你的思想，就能改变你的生活"><a href="#改变你的思想，就能改变你的生活" class="headerlink" title="改变你的思想，就能改变你的生活"></a>改变你的思想，就能改变你的生活</h1><p><a href="https://www.zhihu.com/people/msnzs-74"><img src="https://picd.zhimg.com/v2-ce94f70c723d98a1be108b343e1b1fed_l.jpg?source=172ae18b" alt="maybe"></a></p><p>我们思想的本质决定了我们生活的质量，无论它是悲伤、快乐还是满足。快乐、乐观、积极的想法、情绪和感觉会在我们的系统中产生一种活力，使血液自由流动，使心跳愉快。他们在我们的脚上创造了一个弹簧，激励我们行动。让我们记住那句古老的谚语:思想——思想——可以移山。另一方面，悲观、悲伤和悲观的想法会产生惰性，迫使我们停留在床上。</p><p>我们的行动是我们思想的实际表现。</p><p>因此，很明显，为了在我们的生活中创造幸福和成就感，我们必须改变我们的思维方式。我们大脑的一个优点是，它愿意接受我们给自己的思维模式带来的任何改变。</p><blockquote><p>思考到底为了什么而改变！</p></blockquote><h3 id="1-通过创造积极的肯定来改变你的想法"><a href="#1-通过创造积极的肯定来改变你的想法" class="headerlink" title="1.通过创造积极的肯定来改变你的想法"></a>1.通过创造积极的肯定来改变你的想法</h3><p>肯定并不总是积极的。它们也可能是消极的。女巫们制造的魔咒是否定的肯定。</p><p>事实上，大多数人都倾向于做出消极的肯定。当你反复思考你不会在某个项目上成功时，这是一种消极的肯定。肯定，无论是消极的还是积极的，都会对大脑的神经功能产生影响。</p><p>积极的肯定就像咒语。他们有一种神圣的精神力量。让我们清楚地创造积极的肯定。它们不应该是规范的或薄弱的。</p><p>像“我应该”、“应该”或“不应该”这样的想法是规范的。</p><p>消极肯定的例子有:“我不能”这样做。这是“相当困难的”。一方面，肯定应该是有力的和坚定的，如“我能”，“我将”，或“我将要”。如上所述，你的大脑总是在适应你的思维模式，并引导你的器官相应地行动。</p><h3 id="2-学会使用句号"><a href="#2-学会使用句号" class="headerlink" title="2.学会使用句号"></a>2.学会使用句号</h3><p>我们不断地思考自己的不幸，思考那些我们深爱并真诚地支持我们的人对我们犯下的错误。我们从未停止为自己犯下的错误咒骂自己。如果我做了这个或那个会发生什么?如果我在将来做这个或那个会发生什么?</p><p>这并不是说我们不应该从过去的错误中吸取教训，不应该明智地规划未来。唯一的一点是，一旦我们从过去中吸取了教训，并决定了我们的未来，我们就应该停止反复思考。</p><h3 id="3-放下受虐狂的需要"><a href="#3-放下受虐狂的需要" class="headerlink" title="3.放下受虐狂的需要"></a>3.放下受虐狂的需要</h3><p>我们常常喜欢沉湎于痛苦之中。我们喜欢产生自我惩罚的想法，或者变得悲观和悲观。下面是一个例子:</p><blockquote><p>“如果我开始卖蜡烛，太阳就不会落山，</p><p>如果我开始卖裹尸布，人们就不会死了。”</p><p>我生来就不幸。我不会想到什么好事的。</p></blockquote><p>这些想法不仅会对大脑造成有害的影响，还会对你的身体健康产生负面影响。</p><h3 id="4-通过计算你的快乐和祝福来改变你的想法"><a href="#4-通过计算你的快乐和祝福来改变你的想法" class="headerlink" title="4.通过计算你的快乐和祝福来改变你的想法"></a>4.通过计算你的快乐和祝福来改变你的想法</h3><p>大多数人认为他们的快乐和祝福是理所当然的，开始抱怨他们没有的东西;或者，当他们面临问题和麻烦的时候。想想那些不如你幸运的人吧。或者，想象一个比现在更糟糕的情况。你哭是因为你的膝盖在事故中受伤了。如果腿断了怎么办?看到杯子满了的那一半感到满意，看到杯子空了的那一半就决心把它斟满。</p><p>感恩开启了充实的生活。它使我们拥有的变得足够，甚至更多。它把拒绝变成接受，把混乱变成有序，把困惑变成清晰。它可以把一顿饭变成一顿大餐，把一所房子变成一个家，把一个陌生人变成一个朋友。~ Melody Beattie</p><h3 id="5-欣赏和享受你已经拥有的"><a href="#5-欣赏和享受你已经拥有的" class="headerlink" title="5.欣赏和享受你已经拥有的"></a>5.欣赏和享受你已经拥有的</h3><p>改变想法的一个好方法就是欣赏和享受你已经拥有的东西。这并不是说你不应该追求更好的生活。享受你已经取得的成功，而不是为你没有得到的而感到悲伤。总是设定更高的基准或目标并没有错，但是不能达到目标不会破坏你已经拥有的乐趣。</p><p>自由转换催眠疗法:如何改变你的思维和改变你的生活</p><p><em>“如果你意识到你拥有的足够多，你就是真正的富有。~老子</em></p><h3 id="6-享受你的成就带来的快乐"><a href="#6-享受你的成就带来的快乐" class="headerlink" title="6.享受你的成就带来的快乐"></a><em>6.享受你的成就带来的快乐</em></h3><p>实现你的目标是一回事;在你完成之后去享受它是另一回事。例如，你娶了你的梦中情人，但很快就厌倦了她，开始寻找新的对象。这是导致婚姻不和谐和破裂的最常见原因之一。</p><p><em>“人的一生有两大目标:第一，得到你想要的;在那之后，去享受它。只有最聪明的人才能实现第二目标。——洛根·皮尔索尔·史密斯</em></p><h3 id="7-在艰难的环境中，要挺直腰板，昂首挺胸"><a href="#7-在艰难的环境中，要挺直腰板，昂首挺胸" class="headerlink" title="7.在艰难的环境中，要挺直腰板，昂首挺胸"></a>7.在艰难的环境中，要挺直腰板，昂首挺胸</h3><p>在不利的条件下，我们往往会意志消沉。我们停下来，感觉很低，好像我们被他们的重量压弯了。这在字面上和比喻上都有发生。然而，如果你像一个下定决心接受挑战的人那样，试着抬起你的精神和你的头，你肯定会感觉更好。这是摆脱抑郁的最好方法。试一试。</p><h3 id="8-让自己变得活泼和孩子气"><a href="#8-让自己变得活泼和孩子气" class="headerlink" title="8.让自己变得活泼和孩子气"></a>8.让自己变得活泼和孩子气</h3><p>儿童以天真单纯而著称。他们很快就忘记了和朋友的争吵，又开始一起玩了。这就是为什么他们通常都是快乐和微笑的原因。翻译成成年人的语言，我们应该学会忘记和原谅。</p><p><em>“伟大的人是不会失去孩子心的人。”~孟子(第四卷</em></p><h3 id="9-在当下寻找幸福和满足"><a href="#9-在当下寻找幸福和满足" class="headerlink" title="9.在当下寻找幸福和满足"></a><em>9.在当下寻找幸福和满足</em></h3><p>不要把幸福和将来的事联系在一起。如果事情像这样发生，我会很高兴的。这就像把你的幸福推迟到一个不确定的未来。更好的选择是尽量把你的悲伤推迟到未来的某个时刻。幸福的时刻是今天，因为昨天已经过去了，你不确定明天会带来什么幸福。</p><p><em>“很简单，我们只能现在感到幸福，而且永远都不会有一个时候不是现在。”——杰拉尔德·贾姆波尔斯基</em></p><h3 id="10-掌控自己的情绪"><a href="#10-掌控自己的情绪" class="headerlink" title="10.掌控自己的情绪"></a><em>10.掌控自己的情绪</em></h3><p>做自己情绪的主人，而不是仆人。你是幸福王国的统治者。不要让别人或环境让你开心或悲伤。不要依赖物质财富来为你创造幸福。无论情况如何，你都应该选择快乐。如果你所爱的人抛弃了你，不要让你的心破碎。如果他/她没有你也能快乐，你也一样。</p><p>自由转换催眠疗法:如何改变你的思维和改变你的生活</p><h3 id="11-带着快乐的决心醒来"><a href="#11-带着快乐的决心醒来" class="headerlink" title="11.带着快乐的决心醒来"></a>11.带着快乐的决心醒来</h3><p>早晨醒来的第一件事就是保持一整天的快乐。花些时间和你花园里的花和植物在一起。听听鸟儿在树上的歌唱，或者看它们在天空中高高地飞翔。或者，到附近的公园散步。记住你的决心，只要你感觉到麻烦就要来，就要保持冷静。你有义务保持快乐。</p><h3 id="12-你的身体是你的圣殿，尊敬它"><a href="#12-你的身体是你的圣殿，尊敬它" class="headerlink" title="12.你的身体是你的圣殿，尊敬它"></a>12.你的身体是你的圣殿，尊敬它</h3><p>保持身体干净、清洁、通风良好。不要把肮脏的、消极的思想和有毒的垃圾食品倒在里面。当你身体或精神上生病时，真的很难保持快乐。思想和身体之间有一种密切的关系。根据你的体质需要，定期进行体育锻炼。订阅一些启发性的全天思考服务来激励你在白天保持快乐。</p><h3 id="13-每天冥想"><a href="#13-每天冥想" class="headerlink" title="13.每天冥想"></a>13.每天冥想</h3><p>大多数瑜伽和冥想大师使用晦涩难懂的术语来描述冥想的练习和目标，这使得冥想的过程变得更加复杂。因此，大多数人往往在冥想过程中打瞌睡，并且完全停止冥想。</p><p>同时，在晚上盘点一下你的一天。记住那些曾经发生的美好的小事。你没有被交通阻塞阻塞。你的车跑得很平稳。你和老板和同事之间没有问题。你吃了一顿美味的午餐或咖啡。感谢你的星星给了我一个愉快的一天。这会让你充满感激之情，让你成为一个更快乐的人。</p><p><em>在冥想时，你的新陈代谢和呼吸频率会降至休息的水平，是深度睡眠的两倍。~迈克·洛夫</em></p><h3 id="14-专注于改变你自己，而不是改变你周围的世界"><a href="#14-专注于改变你自己，而不是改变你周围的世界" class="headerlink" title="14.专注于改变你自己，而不是改变你周围的世界"></a>14.专注于改变你自己，而不是改变你周围的世界</h3><p>你不可能改变你周围的世界。所以，当别人没有达到你的期望时，不要烦恼。最好的方法是改变自己，或者至少适应你不喜欢的人或环境。</p><p><em>永远不要低估你改变自我的能力;永远不要高估你改变他人的能力。~韦恩·戴尔</em></p><h3 id="15-充分利用你所拥有的"><a href="#15-充分利用你所拥有的" class="headerlink" title="15. 充分利用你所拥有的"></a>15. 充分利用你所拥有的</h3><p><img src="https://pic2.zhimg.com/80/v2-2dcb5533e9f19a5bf74ca040244fd4f1_1440w.webp" alt="img"></p><p>充分利用你所拥有的，总比渴望得到你认为最好的要好。完美的状态只有在乌托邦中才会出现，你所生活的世界并不是那种理想的地方。不要担心不完美。“不完美”这个词是由“完美”衍生而来的。即使是最不完美的情况也有一些小的完美元素。</p><p>你通过改变你的思想来改变你的生活。如果你的思想是纯洁的，你的生活将是纯洁的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;改变你的思想，就能改变你的生活&quot;&gt;&lt;a href=&quot;#改变你的思想，就能改变你的生活&quot; class=&quot;headerlink&quot; title=&quot;改变你的思想，就能改变你的生活&quot;&gt;&lt;/a&gt;改变你的思想，就能改变你的生活&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://w</summary>
      
    
    
    
    
    <category term="生活" scheme="http://michael8023.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件管理命令的C++实现（简单）</title>
    <link href="http://michael8023.github.io/post/2003bde4.html"/>
    <id>http://michael8023.github.io/post/2003bde4.html</id>
    <published>2022-11-12T07:43:45.000Z</published>
    <updated>2023-08-04T09:03:24.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux文件管理命令的C-实现（简单）"><a href="#Linux文件管理命令的C-实现（简单）" class="headerlink" title="Linux文件管理命令的C++实现（简单）"></a>Linux文件管理命令的C++实现（简单）</h1><h2 id="代码和思路"><a href="#代码和思路" class="headerlink" title="代码和思路"></a>代码和思路</h2><p>使用<code>dirent.h</code>库中的函数来模拟实现Linux中的文件管理功能，包括打开目录，列出文件与目录，删除文件与目录，新建目录。基本实现了无 <code>-r -f</code>等条件下的模拟。具体注释如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;dirent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FilePath <span class="string">&quot;/home/michael/Desktop/linuxSimulation&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引导函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">help</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;------------------------------&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;操作如下：------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;cd——进入某个文件夹目录&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;cd / 进入根目录&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;cd ..返回上级目录&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;cd xxx（绝对路径或相对路径） 进入某个指定文件夹&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ls——列出当前文件夹下的文件和文件夹&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mkdir——在当前目录下新建文件夹&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mkdir xxx（绝对路径） 在某个绝对路径下创建文件夹&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mkdir xxx（相对路径） 在某个相对路径下创建文件夹&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;rm——删除文件&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;rm xxx 删除当前目录下的某个文件&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打开根目录</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">chdir</span>(FilePath));<span class="comment">//切换到根目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;error&quot;</span>);<span class="comment">//输出错误原因</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//不成功则直接返回</span></span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打开文件夹</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string cdCommand;</span><br><span class="line">cin &gt;&gt; cdCommand;</span><br><span class="line"><span class="keyword">if</span> (cdCommand == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">chdir</span>(FilePath))</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;已经成功切换到根目录&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">perror</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cdCommand == <span class="string">&quot;..&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">chdir</span>(<span class="string">&quot;../&quot;</span>))</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;已经成功返回上级目录&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;切换有误，请重新输入&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cwd = cdCommand.<span class="built_in">data</span>();<span class="comment">//类型转换</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">chdir</span>(cwd)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;已经成功跳转到该目录&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">perror</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//列出当前文件下的文件和文件夹</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ls</span><span class="params">()</span> </span>&#123;<span class="comment">//要求，需要输出类型</span></span><br><span class="line">DIR* dir;</span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">dirent</span>* ptr;</span><br><span class="line">dir = <span class="built_in">opendir</span>(<span class="string">&quot;./&quot;</span> );</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == dir)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ((ptr = <span class="built_in">readdir</span>(dir)) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>,ptr-&gt;d_name);<span class="comment">//指针返回文件名称并且输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">closedir</span>(dir);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在当前目录下新建文件夹</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mkdir1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string dirname;</span><br><span class="line">cin &gt;&gt; dirname;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cwd = dirname.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">mkdir</span>(cwd,<span class="number">0777</span>)) &#123;<span class="comment">//0777文件权限最高</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;创建目录成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">perror</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string dirname;</span><br><span class="line">cin &gt;&gt; dirname;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cwd = dirname.<span class="built_in">data</span>();<span class="comment">//类型转换</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">remove</span>(cwd)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;delete successfully!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">perror</span>(<span class="string">&quot;error&quot;</span>);<span class="comment">//输出错误原因 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">help</span>();</span><br><span class="line"><span class="built_in">root</span>();</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; <span class="built_in">getcwd</span>(<span class="literal">NULL</span>, <span class="number">0</span>) &lt;&lt; <span class="string">&quot;&gt;&quot;</span> ;</span><br><span class="line">string command;</span><br><span class="line">cin &gt;&gt; command;</span><br><span class="line"><span class="keyword">if</span> (command == <span class="string">&quot;cd&quot;</span>) &#123;</span><br><span class="line"><span class="built_in">cd</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">&quot;ls&quot;</span>) &#123;</span><br><span class="line"><span class="built_in">ls</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">&quot;mkdir&quot;</span>) &#123;</span><br><span class="line"><span class="built_in">mkdir1</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">&quot;rm&quot;</span>) &#123;</span><br><span class="line"><span class="built_in">rm</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; command &lt;&lt; <span class="string">&quot;既不是内部命令也不是外部命令，请重新输入&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="所学整理"><a href="#所学整理" class="headerlink" title="所学整理"></a>所学整理</h2><ul><li><h4 id="耦合度底的真正实现"><a href="#耦合度底的真正实现" class="headerlink" title="耦合度底的真正实现"></a>耦合度底的真正实现</h4></li></ul><p>以前都是在书本上看如何通过封装等等操作，这次终于有机会编写一个比较长的代码，通过函数调用从而减少<code>main</code>函数的体量，既容易修改，又美观。</p><ul><li><h4 id="include-lt-direct-h-gt-等文件操作库"><a href="#include-lt-direct-h-gt-等文件操作库" class="headerlink" title="#include&lt;direct.h&gt;等文件操作库"></a><code>#include&lt;direct.h&gt;</code>等文件操作库</h4></li></ul><p>包括 <code>chdir()</code>、<code>mkdir()</code>、<code>perror()</code>、<code>const char* cwd = cdCommand.data();//类型转换</code>、<code>remove()</code>的函数调用以及用法，值得一提的是对于 <code>chmod()</code>改变权限函数的深入理解</p><blockquote><p>改变权限函数</p><p> <code>#include &lt; sys/stat.h&gt;</code></p><p><code>chmod()</code></p></blockquote><p>如果成功则返回 TRUE，否则返回 FALSE。</p><p>语法 <code>chmod(file,mode)</code></p><p>参数描述</p><p>file必需规定要检查的文件。</p><p>mode可选。规定新的权限。</p><p>mode 参数由 4 个数字组成：</p><p>第一个数字永远是 0，</p><p>第二个数字规定所有者的权限，</p><p>第二个数字规定所有者所属的用户组的权限，</p><p>第四个数字规定其他所有人的权限。</p><p>可能的值（如需设置多个权限，请对下面的数字进行总计）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有者可读写，其他人没有任何权限</span></span><br><span class="line"><span class="built_in">chmod</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有者可读写，其他人可读</span></span><br><span class="line"><span class="built_in">chmod</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有者有所有权限，其他所有人可读和执行</span></span><br><span class="line"><span class="built_in">chmod</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="number">0755</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有者有所有权限，所有者所在的组可读</span></span><br><span class="line"><span class="built_in">chmod</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="number">0740</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux文件管理命令的C-实现（简单）&quot;&gt;&lt;a href=&quot;#Linux文件管理命令的C-实现（简单）&quot; class=&quot;headerlink&quot; title=&quot;Linux文件管理命令的C++实现（简单）&quot;&gt;&lt;/a&gt;Linux文件管理命令的C++实现（简单）&lt;/h1</summary>
      
    
    
    
    <category term="学习" scheme="http://michael8023.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux" scheme="http://michael8023.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>cmake</title>
    <link href="http://michael8023.github.io/post/233853f2.html"/>
    <id>http://michael8023.github.io/post/233853f2.html</id>
    <published>2022-10-31T10:16:26.000Z</published>
    <updated>2023-08-04T09:02:13.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cmake-教程"><a href="#cmake-教程" class="headerlink" title="cmake 教程"></a>cmake 教程</h1><h3 id="CMake一个HelloWorld的语法介绍"><a href="#CMake一个HelloWorld的语法介绍" class="headerlink" title="CMake一个HelloWorld的语法介绍"></a>CMake一个HelloWorld的语法介绍</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">project(HELLO)</span><br><span class="line">set(SRC<span class="emphasis">_LIST main.cpp)</span></span><br><span class="line"><span class="emphasis">message(status &quot;this is binary dir &quot; $&#123;HELLO_</span>BINARY<span class="emphasis">_DIR&#125;)</span></span><br><span class="line"><span class="emphasis">message(status &quot;this is source dir&quot; $&#123;HELLO_</span>SOURCE<span class="emphasis">_DIR&#125;)</span></span><br><span class="line"><span class="emphasis">add_</span>executable(hello $&#123;SRC<span class="emphasis">_LIST&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="PROJECT关键字"><a href="#PROJECT关键字" class="headerlink" title="PROJECT关键字"></a>PROJECT关键字</h3><p>可以用来指定工程的名字和支持的语言，默认支持所有语言</p><p>PROJECT(HELLO)</p><p>PROJECT(HELLO CXX C)</p><p>该指定隐式定义了两个CMAKE的变量</p><p><projectname>_BINARY_DIR和<projectname>_SOURCE_DIR</p><p>MESSAGE关键字就可以直接使用这两个变量，当前都指向当前的工作目录，后面会讲外部编译</p><p>问题：如果改了工程名，这两个变量名也会改变</p><p>解决：又定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量内容和原来是一致的</p><h3 id="SET关键字"><a href="#SET关键字" class="headerlink" title="SET关键字"></a>SET关键字</h3><p>用来显示的指定变量的</p><p>set(SRC_LIST main.cpp) SRC_LIST变量就包含了main.cpp</p><p>也可以SET(SRC_LIST main.cpp t1.cpp t2.cpp)</p><h3 id="MESSAGE关键字"><a href="#MESSAGE关键字" class="headerlink" title="MESSAGE关键字"></a>MESSAGE关键字</h3><p>向终端输出用户自定义的信息</p><p>主要包含三种信息：</p><ul><li>SEND_ERROR，产生错误，生成过程被跳过</li><li>SATUS，输出前缀为—的信息</li><li>FATAL_ERROR，立即终止所有CMake的过程</li></ul><h3 id="ADD-EXECUTABLE关键字"><a href="#ADD-EXECUTABLE关键字" class="headerlink" title="ADD_EXECUTABLE关键字"></a>ADD_EXECUTABLE关键字</h3><p>生成可执行文件</p><p>ADD_EXECUTABLE(hello ${SRC_LIST})生成可执行文件hello，源文件读取变量SRC_LIST中的内容</p><p>也可直接写ADD_EXECUTABLE(hello main.cpp)</p><blockquote><p>注意：工程名和生成的可执行文件是没有任何关系的</p></blockquote><h3 id="语法的基本原则"><a href="#语法的基本原则" class="headerlink" title="语法的基本原则"></a>语法的基本原则</h3><ul><li>变量使用${}取值，但是在IF控制语句是直接使用变量名</li><li>指令的参数都是用圆括号括起来的，参数之间使用空格或者逗号分隔开</li><li>指令是大小写无关的，参数和变量是大小写相关的</li></ul><h3 id="语法注意"><a href="#语法注意" class="headerlink" title="语法注意"></a>语法注意</h3><ul><li>SET(SRC_LIST main.cpp)可以写成SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，则必须加双引号</li><li>ADD_EXECUTABLE(hello main)后缀可以不写，他会自动去找cpp和c，但是不建议这样写</li></ul><h3 id="内部构建和外部构建"><a href="#内部构建和外部构建" class="headerlink" title="内部构建和外部构建"></a>内部构建和外部构建</h3><ul><li>内部构建产生的临时文件多</li><li>外部构建就是把生成的文件放在build文件夹下，不会对源文件产生任何的影响</li></ul><h3 id="让Hello-World看起来更像一个工程"><a href="#让Hello-World看起来更像一个工程" class="headerlink" title="让Hello World看起来更像一个工程"></a>让Hello World看起来更像一个工程</h3><ul><li>为工程添加一个子目录src，用来放置工程源代码</li><li>添加一个子目录doc，用来放置这个工程文档的hello.txt</li><li>在工程目录添加文本文件COPYRIGHT,README</li><li>在工程目录添加一个 <code>runhello.sh</code>脚本，用来调用hello二进制</li><li>将构建好后的目标文件放入构建目录的bin子目录</li><li>将doc目录的内容以及COPYRIGHT/README安装到/usr/share/doc/cmake</li></ul><h3 id="将目标文件放入构建目录的bin子目录"><a href="#将目标文件放入构建目录的bin子目录" class="headerlink" title="将目标文件放入构建目录的bin子目录"></a>将目标文件放入构建目录的bin子目录</h3><p><img src="D:\Huawei Share\Screenshot\capture_20221022153432562.bmp" alt="capture_20221022153432562"></p><p>外层CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(hello)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(src bin)</span><br></pre></td></tr></table></figure><p>src下的CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_exectable(hello main.cpp)</span><br></pre></td></tr></table></figure><h3 id="ADD-SUBDIRECTORY指令"><a href="#ADD-SUBDIRECTORY指令" class="headerlink" title="ADD_SUBDIRECTORY指令"></a>ADD_SUBDIRECTORY指令</h3><p>ADD_SUBDORECTORY{source_dir [binary] [EXCLUDE_FROM_ALL]}</p><ul><li>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</li><li>EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example</li><li>add_subdirectory(src bin)</li></ul><p>​        将src子目录加入工程并指定编译输出路径为bin目录</p><p>如果不进行bin目录的指定，那么编译结果（包括中间结果）都将放在build/src</p><ul><li>要写在最外层</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>一种是从代码编译后直接make install安装</li><li>一种是打包时的指定目录安装<ul><li>简单的可以这样指定目录：make install DESTDIR/tmp/test</li><li>稍微复杂的可以这样指定目录：./configure -prefix=/usr</li></ul></li></ul><h3 id="如何安装HelloWorld"><a href="#如何安装HelloWorld" class="headerlink" title="如何安装HelloWorld"></a>如何安装HelloWorld</h3><p>使用cmake一个新指令：INSTALL</p><p>​    INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等</p><p>使用CMAKE一个新的变量：CMAKE_INSTALL_PREFIX</p><p><img src="D:\Huawei Share\Screenshot\capture_20221022155756666.bmp" alt="capture_20221022155756666"></p><h4 id="安装文件COPYRIGHT和README"><a href="#安装文件COPYRIGHT和README" class="headerlink" title="安装文件COPYRIGHT和README"></a>安装文件COPYRIGHT和README</h4><p>INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake)</p><p>FILES:文件</p><p>DESTINATION:</p><ol><li>写绝对路径</li><li>可以写相对路径，相对路径其实是：${CMAKE_INSTALL_PREFIX}/<DESTINATION定义的路径></li></ol><p>​        CMAKE_INSTALL_PREFIX 默认是在/usr/local/</p><p>​        cmake -DCMAKE_INSTALL_PREFIX=/usr 在cmake的时候指定的DCMAKE_INSTALL_PREFIX变量的路径</p><h4 id="安装脚本"><a href="#安装脚本" class="headerlink" title="安装脚本"></a>安装脚本</h4><p>PROGRAMS:非可执行程序</p><p>INSTALL(PROGRAMS runhello.sh DESTINATION bin)</p><h4 id="安装doc中的hello-txt"><a href="#安装doc中的hello-txt" class="headerlink" title="安装doc中的hello.txt"></a>安装doc中的hello.txt</h4><p>一、是通过在Doc目录中建立CMakeLists.txt，通过install下的file</p><p>二、是直接在工程目录通过</p><p>INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake)</p><p>DESTINATION后面连接的是所在Source目录的相对路径</p><blockquote><p>注意：doc目录不以/结尾，表示安装这个目录</p><p>以/结尾，表示安装这个目录下的内容</p></blockquote><h3 id="静态库和动态库的构建"><a href="#静态库和动态库的构建" class="headerlink" title="静态库和动态库的构建"></a>静态库和动态库的构建</h3><p>任务：</p><ol><li>建立一个静态库和动态库，提供HelloFunc函数供其他程序编程使用，HelloFunc向终端输出Hello World字符</li><li>安装头文件与共享库</li></ol><p>静态库与动态库的区别</p><ul><li>静态库的扩展名一般为“.a”或”.lib”；动态库的扩展名一般为”.so” or “.dll”</li><li>静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行</li><li>动态库在编译的时候不会放到连接的目标程序中，即可执行文件无法独立运行</li></ul><h4 id="ADD-LIBRARY"><a href="#ADD-LIBRARY" class="headerlink" title="ADD_LIBRARY"></a>ADD_LIBRARY</h4><p>ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})</p><ul><li>HELLO:就是库名，最后生成的时lib会加到前面，即为libhello.so</li><li>SHARED,动态库    STATIC，静态库</li><li>${LIBHELLO_SRC}源文件</li></ul><blockquote><p>若要同时构建动态库和静态库，则必须把两个库的名字区别开，否则只会构建出动态库</p></blockquote><p>同时构建动态库和静态库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>(LIBHELLO_SRC hello.cpp)</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello_static STATIC <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"><span class="comment">#对hello_static重命名为hello</span></span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">#cmake在构建一个新的target时，会尝试清理掉其他这个名字的库，比如，在构建libhello.so时，就会清理掉libhello.a</span></span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello SHARED <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello PROPERTIES OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="安装共享库和头文件"><a href="#安装共享库和头文件" class="headerlink" title="安装共享库和头文件"></a>安装共享库和头文件</h4><p>本例中我们将hello的共享库安装到<prefix>/lib目录</p><p>将hello.h安装到<prefix>/include/hello目录</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSTALL</span>(FIELS hello.h DESTINATION <span class="keyword">include</span>/hello)</span><br><span class="line"><span class="comment">#二进制，静态库，动态库都用TARGET</span></span><br><span class="line"><span class="comment">#ARCHIVE 特指静态库，LIBRARY特指动态库，RUNTIME，特指可执行目标二进制</span></span><br><span class="line"><span class="keyword">INSTALL</span>(<span class="keyword">TARGET</span> hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)</span><br></pre></td></tr></table></figure><h4 id="使用共享库和头文件"><a href="#使用共享库和头文件" class="headerlink" title="使用共享库和头文件"></a>使用共享库和头文件</h4><p>解决：make后头文件找不到的问题</p><p>PS：include <hello/hello.h></p><p>关键字：INCLUDE_DIRECTORIES 这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分隔</p><p>在CMakeLists.txt中加入头文件搜索路径</p><p>INCLUDE_DIRECTORIES(/usr/include/hello)</p><p>解决：找到引用函数问题</p><p>关键字：LINK_DIRECTORIES(/usr/include/hello)添加非标准的共享库搜索路径</p><p>关键字：TARGET_LINK_LIBRARIES(可执行文件名  共享库)</p><blockquote><p>在CMakeLists.txt中插入连接共享库，主要要插在executable后面</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cmake-教程&quot;&gt;&lt;a href=&quot;#cmake-教程&quot; class=&quot;headerlink&quot; title=&quot;cmake 教程&quot;&gt;&lt;/a&gt;cmake 教程&lt;/h1&gt;&lt;h3 id=&quot;CMake一个HelloWorld的语法介绍&quot;&gt;&lt;a href=&quot;#CMake一个</summary>
      
    
    
    
    <category term="学习" scheme="http://michael8023.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="工程部署" scheme="http://michael8023.github.io/tags/%E5%B7%A5%E7%A8%8B%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV learning</title>
    <link href="http://michael8023.github.io/post/a206aef0.html"/>
    <id>http://michael8023.github.io/post/a206aef0.html</id>
    <published>2022-10-31T08:14:30.000Z</published>
    <updated>2023-08-04T11:54:00.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="opencv-note"><a href="#opencv-note" class="headerlink" title="opencv note"></a>opencv note</h1><ul><li><p>第一章 安装</p></li><li><p>第二章 核心功能</p><ul><li><p>基本图像容器 Mat </p></li><li><p>矩阵掩码 </p></li><li><p>改变图像的对比度和亮度</p></li><li><p>基本绘图</p></li><li><p>随机数和文字输入</p></li><li><p>输出 XML 和 YAML 文件</p></li></ul></li><li><p>第三章 图像处理</p><ul><li><p>腐蚀与膨胀；形态学变换</p></li><li><p>基本的阈值操作</p></li><li><p>在图像中寻找轮廓</p></li><li><p>为轮廓创建可倾斜的边界框和椭圆</p></li></ul></li></ul><h3 id="4-1-2-Mat-结构的使用"><a href="#4-1-2-Mat-结构的使用" class="headerlink" title="4.1.2 Mat 结构的使用"></a>4.1.2 Mat 结构的使用</h3><p>​    关于Mat类，我们首先要知道的是：</p><p>（1）不必再手动为其开辟空间。</p><p>（2）不必再在不需要时立即将空间释放</p><p>总结：</p><ul><li>OpenCV 函数中输出图像的内存分配是自动完成的</li><li>使用opencv的c++结构时不需要考虑内存释放的问日</li><li>赋值运算符和拷贝构造函数 <code>Mat B(A)</code>只复制信息头</li><li>使用函数 <code>clone（）</code>或者 <code>copyTo（）</code>来复制一副图像的矩阵 </li></ul><h3 id="4-1-3-像素值的存储方法"><a href="#4-1-3-像素值的存储方法" class="headerlink" title="4.1.3 像素值的存储方法"></a>4.1.3 像素值的存储方法</h3><ul><li>RGB/RGBA</li><li>YCrCb在JPEG中广泛使用</li><li>HSV和HLS 把颜色分解成色调、饱和度和亮度。</li></ul><h3 id="4-1-4-显式创建Mat对象的七种方式"><a href="#4-1-4-显式创建Mat对象的七种方式" class="headerlink" title="4.1.4 显式创建Mat对象的七种方式"></a>4.1.4 显式创建Mat对象的七种方式</h3><ul><li><p>【方法一】使用Mat（）构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">M</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>,CV_8UC3,Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>))</span></span>;</span><br><span class="line"><span class="comment">//CV_[位数][带符号与否][类型前缀]C[通道数]</span></span><br><span class="line"><span class="comment">//预先定义的通道数可以多达4个</span></span><br></pre></td></tr></table></figure></li><li><p>【方法二】在C/C++中通过构造函数进行初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sz[<span class="number">3</span>]=&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="function">Mat <span class="title">L</span><span class="params">(<span class="number">3</span>,sz,cv_8UC,Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="comment">//上面的例子演示了如何创建一个超过两维的矩阵：指定维数，然后传递给一个指向数组的指针，这个数组包含每个维度的尺寸；后续两个参数与方法一中的相同</span></span><br></pre></td></tr></table></figure></li><li><p>【方法三】为已存在的IplImage指针创建信息头</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IplImage* img = <span class="built_in">cvLoadImage</span>(<span class="string">&quot;1.jpg&quot;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="function">Mat <span class="title">mtx</span><span class="params">(img)</span></span>;<span class="comment">//转换 IplImage*-&gt;Mat</span></span><br></pre></td></tr></table></figure></li><li><p>【方法四】利用Create（）函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M.<span class="built_in">create</span>(<span class="number">4</span>,<span class="number">4</span>,<span class="built_in">CV_8UC</span>(<span class="number">2</span>));</span><br><span class="line"><span class="comment">//需要注意的是，此方法不能为矩阵设初值，只是在该百年尺寸时重新为矩阵数据开辟内存而已。</span></span><br></pre></td></tr></table></figure></li><li><p>【方法六】对小矩阵使用逗号分隔式初始化函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mat C = (<span class="built_in">Mat_</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>,<span class="number">3</span>)&lt;&lt;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">5</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;C = &quot;</span>&lt;&lt;endl&lt;&lt;<span class="string">&quot; &quot;</span>&lt;C&lt;&lt;endl&lt;&lt;endl;</span><br></pre></td></tr></table></figure></li><li><p>【方法七】为已存在的对象创建新信息头</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mat RowClone = C.<span class="built_in">row</span>(<span class="number">1</span>).<span class="built_in">clone</span>();</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;RowClone = &quot;</span>&lt;&lt;endl&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;RowClone&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"><span class="comment">//方法七为使用成员函数clone()或者copyTo()为一个已存在的Mat对象创建一个新的信息头</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="cvtColor"><a href="#cvtColor" class="headerlink" title="cvtColor"></a>cvtColor</h1><ul><li>cvtColor的功能是把图像从一个色彩空间转换到另外一个色彩空间，有三个参数，第一个参数表示源图像，第二个参数表示色彩空间转换之后的图像，第三个参数表示源和目标色彩空间如：COLOR_BGR2HLS、COLOR_BGR2GRAY等</li><li>cvtColor(image,gray_image,COLOR_BGR2GRAY);</li></ul><h1 id="imwrite"><a href="#imwrite" class="headerlink" title="imwrite"></a>imwrite</h1><ul><li>保存文件到指定的目录途径</li><li>只有8位，16位的PNG/JPG/Tiff文件格式而且是单通道或者三通道的BGR图像 才可以通过这种方式保存</li><li>保存PNG格式的时候可以保存透明通道的图片（RGBA）</li><li>可以指定压缩参数</li></ul><h1 id="矩阵的掩码操作"><a href="#矩阵的掩码操作" class="headerlink" title="矩阵的掩码操作"></a>矩阵的掩码操作</h1><ul><li><p>获取图像像素指针</p></li><li><p>掩码操作解释</p></li><li>代码演示</li></ul><p>像素处理范围 <code>saturate_cast&lt;uchar&gt;</code>  这个函数的功能是确保RGB值得范围在0~255之间</p><p>掩码操作实现图像对比度的调整 $I(i,j)=5*I(i,j)-[I(i-1,j)+I(i+1,j)+I(i,j-1),I(i,j+1)]$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Mat src = <span class="built_in">imread</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line">Mat dst;</span><br><span class="line"><span class="keyword">if</span> (!src.data)<span class="comment">//如果图像为空，返回 error</span></span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;can&#x27;t load this img&quot;</span> &lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;input image&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;input image&quot;</span>, src);</span><br><span class="line"><span class="comment">//RGB图像按列存储，注意存储顺序是BGR</span></span><br><span class="line"><span class="type">int</span> cols = (src.cols - <span class="number">1</span>) * src.<span class="built_in">channels</span>();</span><br><span class="line">    <span class="comment">//cols 应该用width更为妥当，-1是因为要空出一列像素以防无定义</span></span><br><span class="line"><span class="type">int</span> offsetx = src.<span class="built_in">channels</span>();</span><br><span class="line">    <span class="comment">//偏移量是通道数</span></span><br><span class="line"><span class="type">int</span> rows = src.rows;</span><br><span class="line">    <span class="comment">//RGB按照列存储，与行数无关</span></span><br><span class="line">dst = Mat::<span class="built_in">zeros</span>(src.<span class="built_in">size</span>(), src.<span class="built_in">type</span>());</span><br><span class="line">    <span class="comment">//重新创建一个mat矩阵用于存放输出的图像</span></span><br><span class="line">    <span class="comment">//src.copyTo(dst);也可</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">1</span>; row &lt; rows - <span class="number">1</span>; row++) &#123;</span><br><span class="line"><span class="type">const</span> uchar* previous = src.<span class="built_in">ptr</span>&lt;uchar&gt;(row - <span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> uchar* current = src.<span class="built_in">ptr</span>&lt;uchar&gt;(row);</span><br><span class="line"><span class="type">const</span> uchar* next = src.<span class="built_in">ptr</span>&lt;uchar&gt;(row +<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//创建核的数组</span></span><br><span class="line">uchar* output = dst.<span class="built_in">ptr</span>&lt;uchar&gt;(row);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = offsetx; col &lt; cols; col++) &#123;</span><br><span class="line">output[col] = <span class="built_in">saturate_cast</span>&lt;uchar&gt;(<span class="number">5</span> * current[col] - (current[col - offsetx] + current[col + offsetx] + previous[col] + next[col]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;constrast image&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;constrast image&quot;</span>, dst);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2021070916590138.png" alt="img"></p><h2 id="函数filter-2D实现掩码操作"><a href="#函数filter-2D实现掩码操作" class="headerlink" title="函数filter 2D实现掩码操作"></a>函数filter 2D实现掩码操作</h2><p>可直接用opencv的API做掩码操作来提高对比度</p><p><strong>filter2D(src,dst,src.depth(),kernel):其中src与dst是Mat类型变量，src.depth表示位图深度，有32、24、8等，直接写-1表示与输入图深度一致。（filter滤波器）</strong></p><p>定义掩码： <code>Mat lernel = (Mat_&lt;char&gt;(3,3)&lt;&lt;0,-1,0,-1,5,-1,0,-1,0);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">Mat src = <span class="built_in">imread</span>(<span class="string">&quot;C:/Users/admin/Desktop/lenna.png&quot;</span>);<span class="comment">//读入图片</span></span><br><span class="line">Mat dst;<span class="comment">//提高对比度之后的图片矩阵</span></span><br><span class="line"><span class="keyword">if</span> (src.<span class="built_in">empty</span>())&#123; <span class="comment">// 特判</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cannot see\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;opencv setup1&quot;</span>, CV_WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;opencv setup1&quot;</span>, src);</span><br><span class="line">Mat kernel = (<span class="built_in">Mat_</span>&lt;<span class="type">char</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);<span class="comment">//定义掩码规则</span></span><br><span class="line"><span class="built_in">filter2D</span>(src, dst, src.<span class="built_in">depth</span>()<span class="comment">/*-1*/</span>, kernel);</span><br><span class="line"><span class="comment">//输出目标图像</span></span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;opencv setup2&quot;</span>, CV_WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;opencv setup2&quot;</span>, dst);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);   <span class="comment">//以便在退出程序前调用系统的暂停命令暂停命令行</span></span><br><span class="line"><span class="comment">//爽得很！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Mat"><a href="#Mat" class="headerlink" title="Mat"></a>Mat</h2><p>mat对象的使用：</p><ul><li>部分复制：一般情况下只会复制mat对象的头和指针部分，不会复制数据部分 </li><li>完全复制：使用如下两个API：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mat F=A.<span class="built_in">clone</span>();</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">Mat G;</span><br><span class="line">A.<span class="built_in">copyTo</span>(G);</span><br></pre></td></tr></table></figure><p>函数用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Mat src = <span class="built_in">imread</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!src.data)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;can&#x27;t load this img&quot;</span> &lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//namedWindow(&quot;input image&quot;, WINDOW_AUTOSIZE);</span></span><br><span class="line"><span class="comment">//imshow(&quot;input image&quot;, src);</span></span><br><span class="line"><span class="comment">/*Mat dst;</span></span><br><span class="line"><span class="comment">dst = Mat(src.size(), src.type());</span></span><br><span class="line"><span class="comment">dst = Scalar(255, 0, 255);</span></span><br><span class="line"><span class="comment">namedWindow(&quot;out put&quot;, WINDOW_AUTOSIZE);</span></span><br><span class="line"><span class="comment">imshow(&quot;out put&quot;, dst);*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*Mat dst = src.clone();</span></span><br><span class="line"><span class="comment">namedWindow(&quot;out put&quot;, WINDOW_AUTOSIZE);</span></span><br><span class="line"><span class="comment">imshow(&quot;out put&quot;, dst);*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Mat dst;</span></span><br><span class="line"><span class="comment">//cvtColor(src, dst, COLOR_BGR2GRAY); </span></span><br><span class="line"><span class="comment">//namedWindow(&quot;out put&quot;, WINDOW_AUTOSIZE);</span></span><br><span class="line"><span class="comment">//imshow(&quot;out put&quot;, dst);</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; src.channels() &lt;&lt; endl;//通道数目</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; dst.channels() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//int cols = dst.cols;//全部的列</span></span><br><span class="line"><span class="comment">//int rows = dst.rows;//全部的行</span></span><br><span class="line"><span class="comment">//const uchar* firstRow = dst.ptr&lt;uchar&gt;(0);</span></span><br><span class="line"><span class="comment">//printf(&quot;%d&quot;, *firstRow);</span></span><br><span class="line"><span class="function">Mat <span class="title">M</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>, CV_8UC3, Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line">    </span><br><span class="line">    Mat  m1;</span><br><span class="line">    m1.<span class="built_in">create</span>(src.<span class="built_in">size</span>(),src.<span class="built_in">type</span>());</span><br><span class="line">    m1=<span class="built_in">Scalar</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>);</span><br><span class="line">    </span><br><span class="line">    Mat m2 = Mat::<span class="built_in">zeros</span>(src.<span class="built_in">size</span>(),src.<span class="built_in">type</span>()); </span><br><span class="line">      Mat m2 = Mat::<span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">2</span>,CV_8UC1);</span><br><span class="line">      Mat m2 = Mat::<span class="built_in">eye</span>(<span class="number">2</span>,<span class="number">2</span>,CV_8UC1); </span><br><span class="line">    </span><br><span class="line">cout &lt;&lt; M &lt;&lt; endl;</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图片操作"><a href="#图片操作" class="headerlink" title="图片操作"></a>图片操作</h1><h2 id="读写图像"><a href="#读写图像" class="headerlink" title="读写图像"></a>读写图像</h2><ul><li><code>imread</code>可以指定加载为灰度图像或者RGB图像</li><li><code>imwrite</code>保存图像文件，类型由扩展名决定</li></ul><h2 id="读写像素（pixel）"><a href="#读写像素（pixel）" class="headerlink" title="读写像素（pixel）"></a>读写像素（pixel）</h2><ul><li>读取一个GRAY像素点的像素值(CV_8UC1)</li></ul><p><code>Scalar intensity = img.at&lt;uchar&gt;(y,x);</code>或者</p><p><code>Scalar intensity = img.at&lt;uchar&gt;(Point(y,x));</code></p><ul><li>读一个RGB像素点的像素值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vec3f intensity = img.at&lt;Vec3f&gt;(y,x);</span><br><span class="line">float blue = intensity.val[0];</span><br><span class="line">float green = intensity.val[1];</span><br><span class="line">float red = intensity.val[2];</span><br></pre></td></tr></table></figure><ul><li><p>获取像素的练习</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/utils/logger.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cv::utils::logging::<span class="built_in">setLogLevel</span>(utils::logging::LOG_LEVEL_SILENT);<span class="comment">//不再输出日志</span></span><br><span class="line">Mat src = <span class="built_in">imread</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!src.data) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;could not load this image...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> output_origin[] = <span class="string">&quot;origin demo&quot;</span>;</span><br><span class="line"><span class="type">char</span> output_gray[] = <span class="string">&quot;gray demo&quot;</span>;</span><br><span class="line"><span class="built_in">namedWindow</span>(output_origin, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(output_origin, src);</span><br><span class="line">Mat dst;</span><br><span class="line"><span class="built_in">cvtColor</span>(src, dst, COLOR_BGR2GRAY);</span><br><span class="line"><span class="built_in">namedWindow</span>(output_gray, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(output_gray, dst);</span><br><span class="line">dst.<span class="built_in">create</span>(src.<span class="built_in">size</span>(), src.<span class="built_in">type</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; dst.rows; row++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt;dst.cols; col++) &#123;</span><br><span class="line"><span class="comment">//int gray = dst.at&lt;uchar&gt;(row,col);</span></span><br><span class="line"><span class="comment">//dst.at&lt;uchar&gt;(row,col) = 255 - gray;</span></span><br><span class="line"><span class="type">int</span> b = src.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> g = src.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> r = src.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">2</span>];</span><br><span class="line">dst.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">0</span>]=<span class="number">255</span>-b;</span><br><span class="line">dst.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">1</span>] = <span class="number">255</span> -g;</span><br><span class="line">dst.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">2</span>] = <span class="number">255</span> - r;</span><br><span class="line">            <span class="comment">//另一种转换成灰度图像的方法：</span></span><br><span class="line">            <span class="comment">//dst.at&lt;uchar&gt;(row,col)=max(r,max(b,g));</span></span><br><span class="line">            <span class="comment">//dst.at&lt;uchar&gt;(row,col)=min(r,min(b,g));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;anti color demo&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;anti color demo&quot;</span>, dst);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//已经有封装好的API干嘛要练习这个</span></span><br><span class="line"><span class="built_in">bitwise_not</span>(src,dst);</span><br></pre></td></tr></table></figure><h3 id="Vec3b与Vec3f"><a href="#Vec3b与Vec3f" class="headerlink" title="Vec3b与Vec3f"></a>Vec3b与Vec3f</h3></li><li><p>Vec3b对应的三通道的顺序是blue、green、red的uchar类型的数据</p></li><li><p>Vec3f对应三通道的float类型数据</p></li><li><p>把CV_8UC1转换到CV32F1实现如下： <code>src.convertTo(dst,CV_32F);</code></p></li></ul><h1 id="图像混合"><a href="#图像混合" class="headerlink" title="图像混合"></a>图像混合</h1><h4 id="理论-线性混合操作"><a href="#理论-线性混合操作" class="headerlink" title="理论-线性混合操作"></a>理论-线性混合操作</h4><script type="math/tex; mode=display">g(x)=(1-\alpha)f_0(x)+\alpha f_1(x)\\其中\alpha的取值范围为0到1之间</script><p>相关的API(addWeighted):</p><p><code>addWeight(src1,alpha,src2,beta,gamma(校验值),dst);</code></p><p>$dst(I)=saturate_cast(src1(I)<em>alpha+src2(I)</em>beta+gamma)$</p><h1 id="改变图像的亮度和对比度"><a href="#改变图像的亮度和对比度" class="headerlink" title="改变图像的亮度和对比度"></a>改变图像的亮度和对比度</h1><p>理论：</p><ul><li><p>图像变换可以看作如下：</p><ul><li>像素变换——点操作</li><li>邻域操作——区域</li></ul><p>调整图像亮度属于像素变换-点操作$g(i,j)=\alpha f(i,j)+\beta$其中$\alpha$&gt;0,$\beta$是增益变量</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Mat src = <span class="built_in">imread</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line"><span class="type">char</span> input_win[] = <span class="string">&quot;src image&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (!src.data) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;could not load the image...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">namedWindow</span>(input_win, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(input_win, src);</span><br><span class="line">Mat dst;</span><br><span class="line"><span class="type">int</span> height = src.rows;</span><br><span class="line"><span class="type">int</span> width = src.cols;</span><br><span class="line">dst = Mat::<span class="built_in">zeros</span>(src.<span class="built_in">size</span>(), src.<span class="built_in">type</span>());</span><br><span class="line"><span class="type">double</span> alpha = <span class="number">1.5</span>;</span><br><span class="line"><span class="type">double</span> beta = <span class="number">10</span>;</span><br><span class="line">src.<span class="built_in">convertTo</span>(src, CV_32F);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; height; row++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; width; col++) &#123;</span><br><span class="line"><span class="keyword">if</span> (src.<span class="built_in">channels</span>()  <span class="number">3</span>) &#123;</span><br><span class="line"><span class="type">float</span> b = src.<span class="built_in">at</span>&lt;Vec3f&gt;(row, col)[<span class="number">0</span>];</span><br><span class="line"><span class="type">float</span> g = src.<span class="built_in">at</span>&lt;Vec3f&gt;(row, col)[<span class="number">1</span>];</span><br><span class="line"><span class="type">float</span> r = src.<span class="built_in">at</span>&lt;Vec3f&gt;(row, col)[<span class="number">2</span>];</span><br><span class="line">dst.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">0</span>] = <span class="built_in">saturate_cast</span>&lt;uchar&gt;(b * alpha + beta);</span><br><span class="line">dst.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">1</span>] = <span class="built_in">saturate_cast</span>&lt;uchar&gt;(g * alpha + beta);</span><br><span class="line">dst.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">2</span>] = <span class="built_in">saturate_cast</span>&lt;uchar&gt;(r * alpha + beta);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (src.<span class="built_in">channels</span>()  <span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">int</span> v = src.<span class="built_in">at</span>&lt;uchar&gt;(row, col);</span><br><span class="line">dst.<span class="built_in">at</span>&lt;uchar&gt;(row, col) = <span class="built_in">saturate_cast</span>&lt;uchar&gt;(v * alpha + beta);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//else</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> output_title[] = <span class="string">&quot;contrast and brightness change demo&quot;</span>;</span><br><span class="line"><span class="built_in">namedWindow</span>(output_title, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(output_title, dst);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绘制图像和文字"><a href="#绘制图像和文字" class="headerlink" title="绘制图像和文字"></a>绘制图像和文字</h2><ul><li><p>使用Point与Scalar</p><ul><li><p>​    Point表示2D平面上一个点(x,y)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point p;</span><br><span class="line">p.x=<span class="number">10</span>;p.y=<span class="number">8</span>;<span class="comment">//p=Point(10,8);</span></span><br></pre></td></tr></table></figure></li><li><p>Scalar表示四个元素的向量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scalar(a,b,c);//a=bule,b=green,c=red表示RGB三个通道</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在图片中插入线、矩形、椭圆、圆、多边形。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">Mat src;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lines</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myRectangle</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myEllipse</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myCircle</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPolygon</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> src = <span class="built_in">imread</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!src.data) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;could not liad this image..&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">lines</span>();</span><br><span class="line"><span class="built_in">myRectangle</span>();</span><br><span class="line"><span class="built_in">myEllipse</span>();</span><br><span class="line"><span class="built_in">myCircle</span>();</span><br><span class="line"><span class="built_in">myPolygon</span>();</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;line_demo&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;line_demo&quot;</span>, src);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lines</span><span class="params">()</span> </span>&#123;<span class="comment">//线</span></span><br><span class="line">Point p1 = <span class="built_in">Point</span>(<span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">Point p2 = <span class="built_in">Point</span>(<span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line">Scalar color =<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"><span class="built_in">line</span>(src, p1, p2, color, <span class="number">5</span>, LINE_AA);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myRectangle</span><span class="params">()</span> </span>&#123;<span class="comment">//矩形</span></span><br><span class="line">Rect rect = <span class="built_in">Rect</span>(<span class="number">200</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">Scalar color = <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"><span class="built_in">rectangle</span>(src, rect, color,<span class="number">1</span>, LINE_8);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myEllipse</span><span class="params">()</span> </span>&#123;<span class="comment">//椭圆</span></span><br><span class="line">Scalar color = <span class="built_in">Scalar</span>(<span class="number">175</span>, <span class="number">145</span>, <span class="number">76</span>);</span><br><span class="line"><span class="built_in">ellipse</span>(src, <span class="built_in">Point</span>(src.cols/ <span class="number">2</span>, src.rows / <span class="number">2</span>), <span class="built_in">Size</span>(src.rows / <span class="number">4</span>, src.cols / <span class="number">8</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">360</span>, color, <span class="number">1</span>, LINE_AA);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myCircle</span><span class="params">()</span> </span>&#123;<span class="comment">//圆</span></span><br><span class="line">Scalar color = <span class="built_in">Scalar</span>(<span class="number">175</span>, <span class="number">146</span>, <span class="number">76</span>);</span><br><span class="line"><span class="built_in">circle</span>(src, <span class="built_in">Point</span>(src.cols / <span class="number">2</span>, src.rows / <span class="number">2</span>), src.cols / <span class="number">4</span>, color, <span class="number">1</span>, LINE_AA);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPolygon</span><span class="params">()</span> </span>&#123;<span class="comment">//多边形</span></span><br><span class="line">Scalar color = <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">Point pts [<span class="number">1</span>][<span class="number">6</span>];</span><br><span class="line">pts[<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">Point</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">pts[<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">Point</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">pts[<span class="number">0</span>][<span class="number">2</span>] = <span class="built_in">Point</span>(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">pts[<span class="number">0</span>][<span class="number">3</span>] = <span class="built_in">Point</span>(<span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">pts[<span class="number">0</span>][<span class="number">4</span>] = <span class="built_in">Point</span>(<span class="number">150</span>, <span class="number">50</span>);</span><br><span class="line">pts[<span class="number">0</span>][<span class="number">5</span>] = <span class="built_in">Point</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="type">const</span> Point* ppts[] = &#123; pts[<span class="number">0</span>] &#125;;</span><br><span class="line"><span class="type">int</span> npt[] = &#123; <span class="number">6</span> &#125;;</span><br><span class="line"><span class="built_in">fillPoly</span>(src, ppts, npt, <span class="number">1</span>, color, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在图像中插入文字。<code>putText();</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">Mat src;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> src = <span class="built_in">imread</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!src.data) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;could not liad this image..&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">putText</span>(src, <span class="string">&quot;hello opencv&quot;</span>, <span class="built_in">Point</span>(src.cols / <span class="number">2</span><span class="number">-60</span>, src.rows / <span class="number">2</span>), FONT_HERSHEY_COMPLEX, <span class="number">0.8</span>, <span class="built_in">Scalar</span>(<span class="number">150</span>, <span class="number">12</span>, <span class="number">255</span>), <span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;line_demo&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;line_demo&quot;</span>, src);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机生成颜色</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>随机生成线条</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">Mat src;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RandowLineDemo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> src = <span class="built_in">imread</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!src.data) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;could not liad this image..&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//putText(src, &quot;hello opencv&quot;, Point(src.cols / 2-60, src.rows / 2), FONT_HERSHEY_COMPLEX, 0.8, Scalar(150, 12, 255), 1, 8);</span></span><br><span class="line"><span class="built_in">RandowLineDemo</span>();</span><br><span class="line"><span class="comment">//namedWindow(&quot;line_demo&quot;, WINDOW_AUTOSIZE);</span></span><br><span class="line"><span class="comment">//imshow(&quot;line_demo&quot;, src);</span></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RandowLineDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">RNG <span class="title">rng</span><span class="params">(<span class="number">12346</span>)</span></span>;<span class="comment">//RNG 变量(种子数)</span></span><br><span class="line">Mat bg = Mat::<span class="built_in">zeros</span>(src.<span class="built_in">size</span>(), src.<span class="built_in">type</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line"><span class="built_in">line</span>(bg, <span class="built_in">Point</span>(rng.<span class="built_in">uniform</span>(<span class="number">0</span>, src.cols), rng.<span class="built_in">uniform</span>(<span class="number">0</span>, src.rows)), <span class="built_in">Point</span>(rng.<span class="built_in">uniform</span>(<span class="number">0</span>, src.cols), rng.<span class="built_in">uniform</span>(<span class="number">0</span>, src.rows)), <span class="built_in">Scalar</span>(rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>), rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>), rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>)), <span class="number">1</span>, LINE_AA);</span><br><span class="line">        <span class="comment">//rng.uniform(范围);</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">waitKey</span>(<span class="number">50</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;RandowLineDemo&quot;</span>, bg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="模糊图像"><a href="#模糊图像" class="headerlink" title="模糊图像"></a>模糊图像</h2><h3 id="模糊原理"><a href="#模糊原理" class="headerlink" title="模糊原理"></a>模糊原理</h3><ul><li>Smooth/Blur是图像处理中最简单和常用的操作之一</li><li>使用该操作的原因之一就是为了给图像预处理的时候减低噪声</li><li>使用Smooth/Blur操作背后是数学的卷积计算 $g(i,j)=\sum\limits_{kj}f(i+k,j+l)h(k,l)$</li><li>通常这些卷积算子计算都是线性操作，所以又叫线性滤波</li><li>归一化盒子滤波（均值滤波）和高斯滤波（权重不一样，会保留一些原有像素特质）</li><li>相关API<ul><li>均值模糊： <code>blur(Mat src,Mat dst,Size(xradius,yradius),Point(-1,-1));</code></li><li>高斯模糊： <code>GaussianBlur(Mat src,Mat dst,Size(11,11),sigmax,sigmay);</code>其中Size（x，y）必须是正数而且是奇数。</li></ul></li></ul><p>均值模糊</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Mat src, dst;</span><br><span class="line">src = <span class="built_in">imread</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (src.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;could not load this image...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;originalDemo&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;originalDemo&quot;</span>, src);</span><br><span class="line"><span class="built_in">blur</span>(src, dst, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;blur3Demo&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;blur3Demo&quot;</span>, dst);</span><br><span class="line"><span class="built_in">blur</span>(src, dst, <span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>), <span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;blur5Demo&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;blur5Demo&quot;</span>, dst);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高斯模糊</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Mat src, dst;</span><br><span class="line">src = <span class="built_in">imread</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (src.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;could not load this image...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;originalDemo&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;originalDemo&quot;</span>, src);</span><br><span class="line"><span class="built_in">GaussianBlur</span>(src, dst, <span class="built_in">Size</span>(<span class="number">11</span>, <span class="number">11</span>), <span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;GaussianBlurDemo&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;GaussianBlurDemo&quot;</span>, dst);</span><br><span class="line"><span class="comment">//blur(src, dst, Size(5, 5), Point(-1, -1));</span></span><br><span class="line"><span class="comment">//namedWindow(&quot;blur5Demo&quot;, WINDOW_AUTOSIZE);</span></span><br><span class="line"><span class="comment">//imshow(&quot;blur5Demo&quot;, dst);</span></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>中值滤波<ul><li>统计排序滤波器</li><li>中值对椒盐噪声有很好的抑制作用</li></ul></li><li>高斯双边滤波<ul><li>均值模糊无法克服边缘像素信息丢失缺陷。原因是均值滤波是基于平均权重</li><li>高斯模糊部分克服了该缺陷，但是无法完全避免，因为没有考虑像素值的不同</li><li>高斯双边模糊-是边缘保留的滤波方法，避免看边缘信息丢失，保留了图像轮廓不变，所以双边模糊需要输入两个，一个空域kernel（空间），一个值域kernel（值）</li></ul></li><li>相关的API<ul><li>中值模糊 <code>medianBlur(Mat src,Mat dest,ksize)</code></li><li>双边模糊 <code>bilateralFilter(src,dest,d=15,150,3);</code><ul><li>15-计算的半径，半径之内的像素都会被纳入计算，如果提供-1则会根据sigma space参数取值</li><li>150-sigma color 决定多少差值之内的像素会被计算</li><li>3-sigma space如果d的值大于0则声明无效，否则根据它来计算d值</li><li>中值模糊的ksize大小必须大于一而且必须是奇数</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Mat src, dst;</span><br><span class="line">src = <span class="built_in">imread</span>(<span class="string">&quot;cat1.jpg&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (src.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;could not load this image...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;originalDemo&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;originalDemo&quot;</span>, src);</span><br><span class="line"><span class="comment">//GaussianBlur(src, dst, Size(11, 11), 5, 5);</span></span><br><span class="line"><span class="comment">//medianBlur(src, dst, 3);</span></span><br><span class="line"><span class="built_in">bilateralFilter</span>(src, dst, <span class="number">15</span>, <span class="number">150</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;BilateralFilterDemo&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;BilateralFilterDemo&quot;</span>, dst);</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="膨胀与腐蚀"><a href="#膨胀与腐蚀" class="headerlink" title="膨胀与腐蚀"></a>膨胀与腐蚀</h2><h4 id="形态学操作-膨胀"><a href="#形态学操作-膨胀" class="headerlink" title="形态学操作-膨胀"></a>形态学操作-膨胀</h4><ul><li>图像形态学操作-基于形状的一系列图像处理操作的合集，主要是基于集合论基础上的形态学数学</li><li>形态学有四个基本操作：膨胀、腐蚀、开、闭</li><li>跟卷积操作类似，假设有图像A和结构元素B，结构元素B在A上面移动，其中B定义其中心为锚点计算B覆盖下A的最大像素值（腐蚀是最小像素值）用来替换锚点的像素，其中B作为结构体可以是任意形状</li></ul><h4 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h4><ul><li><code>getStructuringElement(int shape,Size ksize,Point anchor)</code><ul><li>形状(MORPH_RECT/MORPH_CROSS/MORPH_ELLIPSE)</li><li>大小(奇数)</li><li>锚点 默认是Point(-1,-1)意思就是中心像素</li></ul></li><li><code>dilate(src,dst,kernel)</code></li><li><code>erode(src,dst,kernel)</code></li></ul><h4 id="动态调整结构元素大小"><a href="#动态调整结构元素大小" class="headerlink" title="动态调整结构元素大小"></a>动态调整结构元素大小</h4><ul><li><code>createTrackbar(constString&amp;trackbarname,winname,int*value,int count,Trackbarcallback func,void* userdata=0)</code><ul><li>其中最主要的是callback函数功能。如果设置为NULL就是说只有值update，但是不会调用callback的函数 </li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CallBack_Demo</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span></span>;<span class="comment">//回调函数</span></span><br><span class="line"><span class="type">int</span> element_size = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> Max_size = <span class="number">21</span>;</span><br><span class="line">Mat src, dst;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">src = <span class="built_in">imread</span>(<span class="string">&quot;cat1.jpg&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!src.data) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;could not load this image..&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;input image&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;input image&quot;</span>, src);</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;output image&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">createTrackbar</span>(<span class="string">&quot;Element Size:&quot;</span>, <span class="string">&quot;output image&quot;</span>, &amp;element_size, Max_size, CallBack_Demo);</span><br><span class="line"><span class="built_in">CallBack_Demo</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CallBack_Demo</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> s = element_size * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">Mat structureElement = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(s, s), <span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line"><span class="comment">//dilate(src, dst, structureElement, Point(-1, -1), 1);//膨胀</span></span><br><span class="line"><span class="built_in">erode</span>(src, dst, structureElement, <span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>), <span class="number">1</span>);<span class="comment">//腐蚀</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;output image&quot;</span>, dst);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深入理解createTrackBar函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="comment">//void CallBack_Demo(int, void*);</span></span><br><span class="line"><span class="type">int</span> element_size = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> Max_size = <span class="number">21</span>;</span><br><span class="line">Mat src, dst;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; element_size &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">src = <span class="built_in">imread</span>(<span class="string">&quot;cat1.jpg&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!src.data)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;could not load this image..&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;测试窗口&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">createTrackbar</span>(<span class="string">&quot;数字&quot;</span>, <span class="string">&quot;测试窗口&quot;</span>, &amp;element_size, Max_size, text);</span><br><span class="line"><span class="built_in">text</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="形态学操作"><a href="#形态学操作" class="headerlink" title="形态学操作"></a>形态学操作</h2><ul><li>相关API<ul><li><code>morphologyEx(src,dest,CV_MOP_BLACKHAT,kernel);</code></li><li>Mat src-输入图像</li><li>Mat dest-输出结果</li><li>int OPT-CV_MOP_OPEN/CV_MOP_CLOSE/CV_MOP_GRADIENT/CV_MOP_TOPHAT/CV_MOP_BLACKHAT形态学操作类型</li><li>Mat kernel -结构元素</li><li>int Iteration-迭代次数，默认是1</li></ul></li><li>开操作-open<ul><li>先腐蚀后膨胀</li><li>可以去掉较小的对象</li></ul></li><li>闭操作-close<ul><li>先膨胀后腐蚀</li><li>可以填充小的洞（fill hole）</li></ul></li><li>形态学梯度-MOPGRADIENT<ul><li>膨胀减去腐蚀</li><li>又称为基本梯度（其他还包括-内部梯度、方向梯度）</li></ul></li><li>顶帽-TOPHAT<ul><li>顶帽是原图像与开操作之间的差值图像</li><li>计算结果是把较小的噪声对象呈现出来</li></ul></li><li>黑帽<ul><li>黑帽是闭操作图像与原图像的差值图像</li></ul></li></ul><blockquote><p>针对二值图像进行处理</p></blockquote><h3 id="形态学操作应用-提取水平与垂直线"><a href="#形态学操作应用-提取水平与垂直线" class="headerlink" title="形态学操作应用-提取水平与垂直线"></a>形态学操作应用-提取水平与垂直线</h3><blockquote><p>膨胀：输出的像素值是结构元素覆盖下输入图像的最大像素值</p><p>腐蚀：输出的像素值是结构元素覆盖下输入图像的最小像素值</p></blockquote><p>结构元素</p><ul><li>上述膨胀与腐蚀过程可以使用任意的结构元素</li><li>常见的形状：直线、圆、磁盘形状等各种自定义形状。</li></ul><p>提取步骤</p><ul><li>输入图像imread</li><li>转换为灰度图像-cvtColor</li><li>转换为二值图像-adaptiveThreshold<ul><li>API说明-adaptiveThreshold</li><li>Mat src-输入的图像</li><li>Mat dest-二值图像</li><li>double maxValue-二值图像最大值</li><li>int adaptiveMethod-自适应方法，只能其中之一-ADAPTIVE_THRESH_MEAN_C,ADAPTIVE_THRESH_GAUSSIAN_C</li><li>int thresholdType-阈值类型（binary）</li><li>int blockSize-块大小（15）</li><li>double C-常量C，可以是正数，0，负数（-2）</li></ul></li><li>定义结构元素</li><li>开操作（腐蚀+膨胀）提取水平与垂直线在结构元素上做文章，把结构元素定义为水平线或者垂直线</li><li><code>bitwise_not(src,dst):dst=255-src;</code></li></ul><p>代码样例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">Mat src,temp, dst;</span><br><span class="line">src = <span class="built_in">imread</span>(<span class="string">&quot;0-1.jpg&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (src.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;could not load this img...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;src&quot;</span>, src);</span><br><span class="line"><span class="built_in">cvtColor</span>(src, temp, COLOR_BGR2GRAY);</span><br><span class="line"><span class="built_in">adaptiveThreshold</span>(temp, temp, <span class="number">255</span>, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY, <span class="number">15</span>, <span class="number">-2</span>);</span><br><span class="line">Mat x_kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(src.cols / <span class="number">16</span>, <span class="number">1</span>), <span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">Mat y_kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">1</span>,src.rows/<span class="number">16</span>), <span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line"><span class="built_in">morphologyEx</span>(temp, dst, MORPH_OPEN, x_kernel);</span><br><span class="line"></span><br><span class="line"><span class="built_in">bitwise_not</span>(dst, dst);</span><br><span class="line">    <span class="built_in">blur</span>(dst,dst,<span class="built_in">Size</span>(<span class="number">3</span>,<span class="number">3</span>),<span class="built_in">Point</span>(<span class="number">-1</span>,<span class="number">-1</span>));</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;x_line&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;x_line&quot;</span>, dst);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>去除干扰项 —转换为二值图像—定义核矩形—形态学操作—开</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">Mat src,temp, dst;</span><br><span class="line">src = <span class="built_in">imread</span>(<span class="string">&quot;ganrao.png&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (src.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;could not load this img...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;src&quot;</span>, src);</span><br><span class="line"><span class="built_in">cvtColor</span>(src, temp, COLOR_BGR2GRAY);</span><br><span class="line"><span class="built_in">adaptiveThreshold</span>(temp, temp, <span class="number">255</span>, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY, <span class="number">15</span>, <span class="number">-2</span>);<span class="comment">//自适应阈值，可以转换为二值图像</span></span><br><span class="line">Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>));<span class="comment">//核，getstructingelement获取结构元素</span></span><br><span class="line"><span class="built_in">morphologyEx</span>(temp, dst, MORPH_OPEN, kernel);</span><br><span class="line"><span class="comment">//形态学操作--开--morph——open</span></span><br><span class="line"><span class="built_in">bitwise_not</span>(dst, dst);</span><br><span class="line"></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;干扰去除&quot;</span>, dst);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图像上采样与降采样"><a href="#图像上采样与降采样" class="headerlink" title="图像上采样与降采样"></a>图像上采样与降采样</h3><ul><li><p>图像金字塔概念</p><ul><li>采样越多，分辨率越高，金字塔变换特征是不会改变的</li><li>我们在图像畜栏里中常常会调整图像的大小，最常见的就是放大(zoom in)和缩小(zoom out)，尽管几何变换也可以实现图像放大和缩小，但是这里我们介绍图像金字塔</li><li>一个图像金字塔是一系列图像组成，最底下一张是图像尺寸最大，最上方的图像尺寸最小，从孔金赏从上向下看就像一个古代的金字塔。</li><li>高斯金字塔-用来对图像进行降采样<ul><li>从底向上，逐层降采样得到</li><li>降采样之后图像的大小是M/2*N/2，即得到降采样之后上一层的图片</li><li>高斯金字塔的生成过程分为两步：<ul><li>对当前层进行高斯模糊</li><li>删除当前层的偶数行与列</li></ul></li></ul></li><li>拉普拉斯金字塔-用来重建一张图片根据它的上层降采样图片</li><li>高斯不同（Difference of Gaussian-DOG）<ul><li>定义：就是把一张图像在不同的参属下做高斯模糊之后的结果相减，得到的输出图像。称为高斯不同</li><li>高斯不同是图像的内在特征，在灰度图像增强、角点检测中经常用到</li></ul></li></ul></li><li><p>采样API</p><ul><li>上采样(pyrUp)-zoom in 放大</li><li>降采样（pyrDown)-zoom out 缩小</li></ul><p>如何进行上采样和降采样从而得到高斯金字塔的图像，在一个是如何对每一层进行处理得到它的<strong>DOG</strong>，归一化，<strong>彩色图像通道也可做DOG</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">Mat src,temp, g1,g2,dogImg;</span><br><span class="line">src = <span class="built_in">imread</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (src.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;could not load this img...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;src&quot;</span>, src);</span><br><span class="line"><span class="comment">//DOG</span></span><br><span class="line"><span class="built_in">cvtColor</span>(src, temp, COLOR_BGR2GRAY);<span class="comment">//转换为灰度图像</span></span><br><span class="line"><span class="built_in">GaussianBlur</span>(temp, g1, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//两次高斯模糊</span></span><br><span class="line"><span class="built_in">GaussianBlur</span>(g1, g2, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">subtract</span>(g1, g2, dogImg, <span class="built_in">Mat</span>());<span class="comment">//减去</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//归一化显示</span></span><br><span class="line"><span class="built_in">normalize</span>(dogImg, dogImg, <span class="number">255</span>, <span class="number">0</span>, NORM_MINMAX);<span class="comment">//用此函数也可化为0-1图像</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;DOG Image&quot;</span>, dogImg);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="基本阈值操作（threshold）"><a href="#基本阈值操作（threshold）" class="headerlink" title="基本阈值操作（threshold）"></a>基本阈值操作（threshold）</h3><ul><li>阈值是什么，简单来说是把图像分割的标尺</li></ul><h5 id="阈值类型"><a href="#阈值类型" class="headerlink" title="阈值类型"></a>阈值类型</h5><ul><li><p><strong>阈值二值化</strong>（threshold binary）</p></li><li><p><strong>阈值反二值化</strong>（threshold binary Inverted）</p></li><li><strong>阈值截断</strong>(threshold trunc)</li><li><strong>阈值取零</strong>(threshold to zero)</li><li><strong>阈值反取零</strong>(threshold to zero Inverted)<ul><li>OTSU与TRANGLE</li></ul></li></ul><p>首先转化为灰度图像</p><blockquote><p>阈值操作</p></blockquote><p><code>threshold(src,dst,threshold_value,threshold_max,THRESH_TYPE);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> threshold_value = <span class="number">127</span>;<span class="comment">//阈值</span></span><br><span class="line"><span class="type">int</span> threshold_max = <span class="number">255</span>;<span class="comment">//最大阈值</span></span><br><span class="line">Mat src, dst;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threshold_Demo</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span></span>;<span class="comment">//声明回调函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">src = <span class="built_in">imread</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (src.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;could not load this img...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;input image&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;output image&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;input image&quot;</span>, src);</span><br><span class="line"><span class="built_in">createTrackbar</span>(<span class="string">&quot;threshold&quot;</span>, <span class="string">&quot;output image&quot;</span>, &amp;threshold_value, threshold_max, threshold_Demo);<span class="comment">//创建滑动条</span></span><br><span class="line"><span class="built_in">threshold_Demo</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threshold_Demo</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cvtColor</span>(src, dst, COLOR_BGR2GRAY);<span class="comment">//转换为灰度图</span></span><br><span class="line"><span class="built_in">threshold</span>(dst, dst, threshold_value, threshold_max, THRESH_BINARY);<span class="comment">//转换为二值图像</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;output image&quot;</span>, dst); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="输入输出XML和YAML文件"><a href="#输入输出XML和YAML文件" class="headerlink" title="输入输出XML和YAML文件"></a>输入输出XML和YAML文件</h3><ul><li>XML，是“可扩展表示为语言”，任何满足XML命名规则的名称都可以标记，这就像不同的应用程序打开了大门</li><li>YAML是以数据为中心，而不是以置标语言为重点。YAML是一个可读性高，用来表达资料序列的格式。哦内阁制，YAML试图用一种比XML更敏捷的方式，来完成XML所完成的任务</li></ul><h4 id="FileStorage类操作文件的使用引导"><a href="#FileStorage类操作文件的使用引导" class="headerlink" title="FileStorage类操作文件的使用引导"></a>FileStorage类操作文件的使用引导</h4><p>XML是使用非常广泛的文件格式，可以利用XML或者YAML格式的文件存储和<strong>还原</strong>各式各样的数据结构。当然，他们还可以<strong>存储和载入</strong>任意复杂的数据结构，其中就包括了OpenCV相关周边的数据结构，以及各种原始数据类型，如整数和浮点数字和文本字符串。</p><p>过程：</p><ol><li>实例化一个 <code>FileStorage</code>类的对象，用默认带参数的构造函数完成初始化，或者用 <code>FileStorage::open()</code>成员函数辅助初始化。</li><li>使用流操作符&lt;&lt;进行文件写入操作，或者&gt;&gt;进行文件读取操作，类似C++中的文件输入输出流。</li><li>使用 <code>FileStorage::release()</code>函数析构掉 <code>FileStorage</code>类对象，同时关闭文件。</li></ol><h4 id="示例程序：XML和YAML文件的写入"><a href="#示例程序：XML和YAML文件的写入" class="headerlink" title="示例程序：XML和YAML文件的写入"></a>示例程序：XML和YAML文件的写入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function">FileStorage <span class="title">fs</span><span class="params">(<span class="string">&quot;test.yaml&quot;</span>, FileStorage::WRITE)</span></span>;</span><br><span class="line">fs &lt;&lt; <span class="string">&quot;frameCount&quot;</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line"><span class="type">time_t</span> rawtime;</span><br><span class="line"><span class="built_in">time</span>(&amp;rawtime);</span><br><span class="line">fs &lt;&lt; <span class="string">&quot;calibrationDate&quot;</span> &lt;&lt; <span class="built_in">asctime</span>(<span class="built_in">localtime</span>(&amp;rawtime));</span><br><span class="line">Mat cameraMatrix = (<span class="built_in">Mat_</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1000</span>, <span class="number">0</span>, <span class="number">320</span>, <span class="number">0</span>, <span class="number">1000</span>, <span class="number">240</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">Mat distCoeffs = (<span class="built_in">Mat_</span>&lt;<span class="type">double</span>&gt;(<span class="number">5</span>, <span class="number">1</span>) &lt;&lt; <span class="number">0.1</span>, <span class="number">0.01</span>, <span class="number">-0.001</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">fs &lt;&lt; <span class="string">&quot;cameraMatrix&quot;</span> &lt;&lt; cameraMatrix &lt;&lt; <span class="string">&quot;distCoeffs&quot;</span> &lt;&lt; distCoeffs;</span><br><span class="line">fs &lt;&lt; <span class="string">&quot;features&quot;</span> &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">rand</span>() % <span class="number">640</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="built_in">rand</span>() % <span class="number">480</span>;</span><br><span class="line">uchar lbp = <span class="built_in">rand</span>() % <span class="number">256</span>;</span><br><span class="line">fs &lt;&lt; <span class="string">&quot;&#123;:&quot;</span> &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;y&quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;lbp&quot;</span> &lt;&lt; <span class="string">&quot;[:&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">fs &lt;&lt; ((lbp &gt;&gt; j) &amp; <span class="number">1</span>);</span><br><span class="line">fs &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">fs &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">fs.<span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板匹配（template-match）"><a href="#模板匹配（template-match）" class="headerlink" title="模板匹配（template match）"></a>模板匹配（template match）</h3><ul><li>模板也是一个小的图像，用小图像匹配的过程叫做模板匹配</li><li>从左到右，从上到下计算匹配度</li><li>计算归一化平方不同TM_SQDIFF_NORMED     -1<ul><li>$R(x,y)=\sum\limits_{x’y’}(T(x’,y’)-I(x+x’,y+y’))^2$</li></ul></li><li>计算归一化相关性TM_CCORR_NORMED       ——3</li><li><p>计算归一化相关系数TM_CCOEFF_NORMED   ——-5</p></li><li><p>相关API介绍</p><ul><li>matchTemplate(src,templ,result,method)</li><li>src-源图像，必须是8-bit或者32-bit浮点数图像</li><li>templ-模板图像，类型与输入图像一致</li><li>result-输出结果，必须是单通道32位浮点数，假设源图像W*H，模板图像w*h，则结果必须为W-w+1，H-h+1的大小</li><li>int method 使用的匹配方法</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> trackbar_value = TM_CCOEFF_NORMED;<span class="comment">//阈值，</span></span><br><span class="line"><span class="type">int</span> max_track = <span class="number">5</span>;<span class="comment">//最大阈值/类型数目</span></span><br><span class="line">Mat src, temp, dst;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">templateMatch_demo</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">src = <span class="built_in">imread</span>(<span class="string">&quot;src.jpg&quot;</span>);</span><br><span class="line">temp = <span class="built_in">imread</span>(<span class="string">&quot;template.jpg&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!src.data || !temp.data) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;could not load this image...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//namedWindow(&quot;input img&quot;, WINDOW_AUTOSIZE);</span></span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;output img&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">createTrackbar</span>(<span class="string">&quot;templatemacth&quot;</span>, <span class="string">&quot;output img&quot;</span>, &amp;trackbar_value, max_track, templateMatch_demo);<span class="comment">//创建滑动条</span></span><br><span class="line"><span class="built_in">templateMatch_demo</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">templateMatch_demo</span><span class="params">(<span class="type">int</span> ,<span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> height = src.rows - temp.rows + <span class="number">1</span>;<span class="comment">//格式要求：大-小+1</span></span><br><span class="line"><span class="type">int</span> width = src.cols - temp.cols + <span class="number">1</span>;</span><br><span class="line"><span class="function">Mat <span class="title">result</span><span class="params">(width, height, CV_32FC1)</span></span>;<span class="comment">//要求输出32位单通道用于模板匹配</span></span><br><span class="line"><span class="built_in">matchTemplate</span>(src, temp, result, trackbar_value,<span class="built_in">Mat</span>());<span class="comment">//模板匹配</span></span><br><span class="line"><span class="built_in">normalize</span>(result, result, <span class="number">0</span>, <span class="number">1</span>, NORM_MINMAX,<span class="number">-1</span>,<span class="built_in">Mat</span>());<span class="comment">//归一化0-1图像</span></span><br><span class="line">Point minLoc, maxLoc,temLoc;<span class="comment">//定位</span></span><br><span class="line">src.<span class="built_in">copyTo</span>(dst);<span class="comment">//把源图像给dst</span></span><br><span class="line"><span class="type">double</span> min, max;</span><br><span class="line"><span class="built_in">minMaxLoc</span>(result, &amp;min, &amp;max, &amp;minLoc, &amp;maxLoc,<span class="built_in">Mat</span>());</span><br><span class="line"><span class="keyword">if</span> (trackbar_value  TM_SQDIFF || trackbar_value  TM_SQDIFF_NORMED) &#123;</span><br><span class="line">temLoc = minLoc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> temLoc = maxLoc;</span><br><span class="line"></span><br><span class="line"><span class="built_in">rectangle</span>(dst, <span class="built_in">Rect</span>(temLoc.x, temLoc.y, temp.cols, temp.rows), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),<span class="number">2</span>,<span class="number">8</span>);<span class="comment">//在dst上画出框</span></span><br><span class="line"><span class="built_in">rectangle</span>(result, <span class="built_in">Rect</span>(temLoc.x, temLoc.y, temp.cols, temp.rows), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),<span class="number">2</span>,<span class="number">8</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;output img&quot;</span>, result);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;match&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="轮廓发现（find-contour-in-your-image）"><a href="#轮廓发现（find-contour-in-your-image）" class="headerlink" title="轮廓发现（find contour in your image）"></a>轮廓发现（find contour in your image）</h3><ul><li><strong>轮廓发现</strong>是基于图像边缘提取的基础寻找对象轮廓的方法。所以边缘提取的阈值选定会影响最终轮廓发现效果</li><li><strong>API介绍</strong><ul><li><strong>findContours</strong>发现轮廓<ul><li>img 输入图像，非0的像素被看成1，0的像素保持不变，8-bit</li><li>contours 全部发现的轮廓对象</li><li>hierachy 图像的拓扑结构，可选，该轮廓发现算法正是基于图像拓扑结构实现</li><li>mode 轮廓返回的模式</li><li>method 发现方法</li><li>Point offset-Point（） 轮廓像素的位移，默认（0，0）没有位移</li></ul></li><li><strong>drawContours</strong>绘制轮廓<ul><li>img 输出图像</li><li>contours 全部发现的轮廓对象</li><li>contourldx 轮廓索引号</li><li>color 绘制时候颜色</li><li>thickness 绘制线宽</li><li>lineType 线的类型LINE_8</li><li>hierarchy 拓扑结构图</li><li>maxlevel最大层数，0表示只绘制当前的，1表示绘制当前及其内嵌的轮廓</li></ul></li></ul></li><li>过程<ul><li>输入图像转为灰度图像cvtColor</li><li>使用<strong>Canny</strong>进行边缘提取，得到二值图像</li><li>使用<strong>findContours</strong>寻找轮廓</li><li>使用<strong>drawContours</strong>绘制轮廓</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> threshold_value = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> threshold_max = <span class="number">255</span>;</span><br><span class="line">Mat src, dst;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo_Contours</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span></span>;</span><br><span class="line">RNG rng;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">src = <span class="built_in">imread</span>(<span class="string">&quot;cat3.jpg&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (src.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;could not load this image...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Demo_Contours</span>(<span class="number">0</span>, <span class="number">0</span>);<span class="comment">//contours轮廓</span></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo_Contours</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"><span class="built_in">Canny</span>(src, dst, threshold_value, threshold_value * <span class="number">2</span>, <span class="number">3</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">//Canny（输入，输出，低阈值，高阈值（低阈值的2·3倍），3，false）；</span></span><br><span class="line"><span class="built_in">findContours</span>(dst, contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, <span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));<span class="comment">//寻找轮廓</span></span><br><span class="line">Mat drawImg = Mat::<span class="built_in">zeros</span>(dst.<span class="built_in">size</span>(), CV_8UC3);<span class="comment">//8bit3通道的彩色图像</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++) &#123; </span><br><span class="line">Scalar color = <span class="built_in">Scalar</span>(rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>), rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>), rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>));<span class="comment">//RNG rng生成一个随机数。</span></span><br><span class="line"><span class="built_in">drawContours</span>(drawImg, contours, i, color, <span class="number">2</span>, LINE_8, hierarchy, <span class="number">0</span>, <span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));<span class="comment">//画出轮廓（颜色随机），</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;output&quot;</span>, drawImg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="凸包-Convex-Hull"><a href="#凸包-Convex-Hull" class="headerlink" title="凸包-Convex Hull"></a>凸包-Convex Hull</h3><ul><li>在一个多边形边缘或者内部任意两个点的连线都包含在多边形边界或者内部—-包含集合S中所有点的最小凸多边形称为凸包</li></ul><blockquote><p>Graham扫描算法</p></blockquote><ul><li>首先选择Y方向最低的点作为起始点P0</li><li>从P0开始极坐标扫描，依次添加p1…pn(排序顺序是根据极坐标的角度大小，逆时针方向)</li><li>对每个点pi来说，如果添加pi点到凸包中导致一个左转向（逆时针方向）则添加该点到凸包，反之则从凸包中删除该点。</li></ul><h3 id="API说明-convexHull"><a href="#API说明-convexHull" class="headerlink" title="API说明  convexHull"></a>API说明  convexHull</h3><ul><li>convexHull(</li><li>pointd,//输入候选点，来自findContours</li><li>hull//凸包</li><li>bool clockwise//顺时针方向</li><li>returnPoints)//true表示返回点荷属，如果第二个参数是vector<Point>则自动忽略</li></ul><h3 id="凸包代码演示（凸包只是一个比较特殊的轮廓而已）"><a href="#凸包代码演示（凸包只是一个比较特殊的轮廓而已）" class="headerlink" title="凸包代码演示（凸包只是一个比较特殊的轮廓而已）"></a>凸包代码演示（凸包只是一个比较特殊的轮廓而已）</h3><ul><li>首先把图像从RGB转为灰度</li><li>然后再转为二值图像</li><li>再通过发现轮廓得到候选点</li><li>凸包API调用</li><li>绘制显示</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> threshold_value = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> threshold_max = <span class="number">255</span>;</span><br><span class="line">Mat src,src_gray;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thershold_Callback</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span></span>;</span><br><span class="line"><span class="function">RNG <span class="title">rng</span><span class="params">(<span class="number">12345</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* OUTPUT = <span class="string">&quot;output&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* TRACKBAR = <span class="string">&quot;trackbar&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">src = <span class="built_in">imread</span>(<span class="string">&quot;cat1.jpg&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (src.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;could not load this image...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cvtColor</span>(src, src_gray, COLOR_BGR2GRAY);<span class="comment">//先转化为灰度图像</span></span><br><span class="line"><span class="built_in">blur</span>(src_gray, src_gray, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>));<span class="comment">//然后进行模糊，降低噪声，以用来更好的二值化</span></span><br><span class="line"><span class="built_in">namedWindow</span>(OUTPUT, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">createTrackbar</span>(TRACKBAR, OUTPUT, &amp;threshold_value, threshold_max, Thershold_Callback);</span><br><span class="line"><span class="built_in">Thershold_Callback</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thershold_Callback</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">Mat threshold_output;</span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"><span class="built_in">threshold</span>(src_gray, threshold_output, threshold_value, threshold_max, THRESH_BINARY);<span class="comment">//转化为二值图像</span></span><br><span class="line"><span class="built_in">findContours</span>(threshold_output, contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, <span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));<span class="comment">//通过发现轮廓的到候选点</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">hull</span>(contours.<span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="built_in">convexHull</span>(<span class="built_in">Mat</span>(contours[i]), hull[i], <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">Mat dst = Mat::<span class="built_in">zeros</span>(threshold_output.<span class="built_in">size</span>(), CV_8UC3);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">Scalar color = <span class="built_in">Scalar</span>(rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>), rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>), rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line"><span class="built_in">drawContours</span>(dst, hull, i, color, <span class="number">1</span>, LINE_8, hierarchy, <span class="number">0</span>, <span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="built_in">drawContours</span>(dst, contours, i, color, <span class="number">1</span>, LINE_8, hierarchy, <span class="number">0</span>, <span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(OUTPUT, dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="轮廓周围绘制矩形框和圆形框"><a href="#轮廓周围绘制矩形框和圆形框" class="headerlink" title="轮廓周围绘制矩形框和圆形框"></a>轮廓周围绘制矩形框和圆形框</h3><p>从彩色图像转化为灰度图像，然后进行模糊，然后进行二值化处理，或者使用Canny边缘检测</p><ul><li>API介绍<ul><li><code>approxPolyDP(InputArray curve,OutputArray approxCurve,double epsilon,bool closed)</code>基于RDP算法实现，目的是减少多边形轮廓点数</li><li>轮廓周围矩形绘制-API<ul><li><code>boundingRect(InputArray points)</code>得到轮廓周围最小矩形左上角点坐标和右下角点坐标，绘制一个矩形</li><li><code>minAreaRect(InputArray points)</code>得到一个旋转的矩形，返回旋转矩形</li></ul></li><li>轮廓周围绘制圆和椭圆-API<ul><li><code>minEnclosingCircle(InputArray points)</code>//得到最小区域圆形<ul><li>Point2f&amp; center //圆心位置</li><li>float&amp; radius//圆的半径</li></ul></li><li><code>fitEllipse(InputArray points)</code>得到最小椭圆</li></ul></li></ul></li><li>步骤<ul><li>首先将图像变为二值图像（先变为灰度图像，然后进行模糊，进而用阈值函数变为二值图像，或者用canny边缘检测变为二值图像）</li><li>发现轮廓，找到图像轮廓(<code>findContours</code>)</li><li>通过相关API再轮廓点上找到最小包含矩形和圆，旋转矩形与椭圆。</li><li>绘制他们</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//坏代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> threshold_value = <span class="number">170</span>;</span><br><span class="line"><span class="type">int</span> threshold_max = <span class="number">255</span>;</span><br><span class="line">Mat src, src_gray, dst;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Contours_Callback</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span></span>;</span><br><span class="line"><span class="function">RNG <span class="title">rng</span><span class="params">(<span class="number">12345</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* OUTPUT = <span class="string">&quot;rectangle-Demo&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* TRACKBAR = <span class="string">&quot;trackbar&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">src = <span class="built_in">imread</span>(<span class="string">&quot;cat1.jpg&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (src.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;could not load this image...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cvtColor</span>(src, src_gray, COLOR_BGR2GRAY);<span class="comment">//先转化为灰度图像</span></span><br><span class="line"><span class="built_in">blur</span>(src_gray, src_gray, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>));<span class="comment">//然后进行模糊，降低噪声，以用来更好的二值化</span></span><br><span class="line"><span class="built_in">namedWindow</span>(OUTPUT, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">createTrackbar</span>(TRACKBAR, OUTPUT, &amp;threshold_value, threshold_max, Contours_Callback);</span><br><span class="line"><span class="built_in">Contours_Callback</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Contours_Callback</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">Mat binary_output;<span class="comment">//把灰度图像变为二值图像</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt;contours;</span><br><span class="line">vector&lt;Vec4i&gt; hierachy;</span><br><span class="line"><span class="built_in">threshold</span>(src_gray, binary_output, threshold_value, threshold_max, THRESH_BINARY);</span><br><span class="line"><span class="built_in">findContours</span>(binary_output, contours, hierachy, RETR_TREE, CHAIN_APPROX_SIMPLE, <span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt;<span class="built_in">contours_ploy</span>(contours.<span class="built_in">size</span>());</span><br><span class="line">vector&lt;Rect&gt;<span class="built_in">ploy_rects</span>(contours.<span class="built_in">size</span>());</span><br><span class="line"><span class="function">vector&lt;Point2f&gt; <span class="title">ccs</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">float</span>&gt; <span class="title">radius</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;RotatedRect&gt; <span class="title">minRect</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"><span class="function">vector&lt;RotatedRect&gt; <span class="title">myellipse</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="built_in">approxPolyDP</span>(<span class="built_in">Mat</span>(contours[i]), contours_ploy[i], <span class="number">3</span>, <span class="literal">true</span>);<span class="comment">//初始化</span></span><br><span class="line"><span class="comment">/*ploy_rects[i] = boundingRect(contours_ploy[i]);</span></span><br><span class="line"><span class="comment">minEnclosingCircle(contours_ploy[i], ccs[i], radius[i]);*/</span></span><br><span class="line"><span class="keyword">if</span> (contours_ploy.<span class="built_in">size</span>() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">myellipse[i] = <span class="built_in">fitEllipse</span>(contours_ploy[i]);</span><br><span class="line">minRect[i] = <span class="built_in">minAreaRect</span>(contours_ploy[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">src.<span class="built_in">copyTo</span>(dst);</span><br><span class="line">Point2f pts[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">Scalar color = <span class="built_in">Scalar</span>(rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>), rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>), rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (contours_ploy.<span class="built_in">size</span>() &gt; <span class="number">5</span>) &#123;</span><br><span class="line"><span class="comment">//rectangle(dst, ploy_rects[i], color, 2, LINE_8);</span></span><br><span class="line"><span class="comment">//circle(dst, ccs[i], radius[i], color, 2, LINE_8);</span></span><br><span class="line"><span class="built_in">ellipse</span>(dst, myellipse[i], color, <span class="number">1</span>, LINE_8);</span><br><span class="line">minRect[i].<span class="built_in">points</span>(pts);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; <span class="number">4</span>; r++) &#123;</span><br><span class="line"><span class="built_in">line</span>(dst, pts[r], pts[(r + <span class="number">1</span>) % <span class="number">4</span>], color, <span class="number">1</span>, LINE_8);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(OUTPUT, dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="图像矩（Image-Moments）"><a href="#图像矩（Image-Moments）" class="headerlink" title="图像矩（Image Moments）"></a>图像矩（Image Moments）</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;opencv-note&quot;&gt;&lt;a href=&quot;#opencv-note&quot; class=&quot;headerlink&quot; title=&quot;opencv note&quot;&gt;&lt;/a&gt;opencv note&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一章 安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第</summary>
      
    
    
    
    <category term="学习" scheme="http://michael8023.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="计算机视觉" scheme="http://michael8023.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://michael8023.github.io/post/4a17b156.html"/>
    <id>http://michael8023.github.io/post/4a17b156.html</id>
    <published>2022-10-29T13:20:05.693Z</published>
    <updated>2023-08-04T09:03:18.847Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
    <category term="test" scheme="http://michael8023.github.io/tags/test/"/>
    
  </entry>
  
</feed>
