<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Michael`Blog</title>
  
  <subtitle>Welcome to my metaverse!</subtitle>
  <link href="http://michael8023.github.io/atom.xml" rel="self"/>
  
  <link href="http://michael8023.github.io/"/>
  <updated>2022-10-30T13:47:55.882Z</updated>
  <id>http://michael8023.github.io/</id>
  
  <author>
    <name>Michael Liu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test</title>
    <link href="http://michael8023.github.io/post/d87f7e0c.html"/>
    <id>http://michael8023.github.io/post/d87f7e0c.html</id>
    <published>2022-10-30T13:44:07.000Z</published>
    <updated>2022-10-30T13:47:55.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解计算机系统笔记"><a href="#深入理解计算机系统笔记" class="headerlink" title="深入理解计算机系统笔记"></a>深入理解计算机系统笔记</h1><h2 id="1-4系统的硬件组成"><a href="#1-4系统的硬件组成" class="headerlink" title="1.4系统的硬件组成"></a>1.4系统的硬件组成</h2><p>总线、I/O设备、主存、处理器</p><h2 id="1-5高速缓存"><a href="#1-5高速缓存" class="headerlink" title="1.5高速缓存"></a>1.5高速缓存</h2><p>​    根据机械原理，较大的存储设备要比较小的运行的曼，而快速设备的造价远远高于低速同类设备。</p><p>一个典型的寄存器文件只存储几百字节的信息，与此相反，主存里可存放几百万字节。然而，处理器从寄存器文件中读取数据比从主存中读取要快几乎100倍。</p><p>​    针对这种处理器与主存之间的诧异，系统设计者采用了更小更快的存储设备，称为 <strong>高速缓存存储器</strong>（cache memories），它们被用来作为暂时的集结区域，存放处理器在不久的将来可能会需要的信息。高速缓存是用一种叫做 <strong>静态随机访问存储器（SRAM）</strong>的硬件技术实现的。</p><p><img src="D:\Huawei Share\Screenshot\capture_20221008225034743.bmp" alt="capture_20221008225034743"></p><h2 id="1-6形成层次结构的存储设备"><a href="#1-6形成层次结构的存储设备" class="headerlink" title="1.6形成层次结构的存储设备"></a>1.6形成层次结构的存储设备</h2><p>存储器分层的主要思想是一个层次上的存储器作为下一层次上的存储器的高速缓存。因此，寄存器文件就是L1的高速缓存，而L1又是L2的高速缓存…在某些==带分布式的文件系统==的网络系统中，本地磁盘就是其他系统中磁盘上被存储数据的高速缓存。</p><p><img src="C:\Users\11147\AppData\Roaming\Typora\typora-user-images\image-20221027145140282.png" alt="image-20221027145140282"></p><h2 id="1-7-操作系统管理硬件"><a href="#1-7-操作系统管理硬件" class="headerlink" title="1.7 操作系统管理硬件"></a>1.7 操作系统管理硬件</h2><p>我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统</p><p><img src="C:\Users\11147\AppData\Roaming\Typora\typora-user-images\image-20221027145346249.png" alt="image-20221027145346249"></p><p>操作系统功能：</p><ul><li>放置硬件被失控的应用程序滥用</li><li>在控制复杂而又通常广泛不同的低级硬件设备方面，为应用程序提供简单一致的方法</li></ul><p><img src="C:\Users\11147\AppData\Roaming\Typora\typora-user-images\image-20221027145604659.png" alt="image-20221027145604659"></p><h3 id="1-7-1-进程"><a href="#1-7-1-进程" class="headerlink" title="1.7.1 进程"></a>1.7.1 进程</h3><p>进程是计算机科学中最重要和最成功的概念之一</p><p>​    进程是操作系统对运行程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占的使用硬件。我们称之为<strong>并发运行</strong>，实际上是说一个进程的指令和另一个进程的指令是交错执行的。操作系统实现这种交错执行的机制称为上下文切换（context switching）</p><p>​    操作系统保存进程运行所需要的所有状态信息。这种状态，也就是上下文（context），包括PC和寄存器文件的当前值，以及主存的内容。在任何一个时刻，系统上都只有一个进程正在运行。当操作系统决定从当前进程转移控制权到新进程时，他就会进行context switching，即保存当前进程的上下文，恢复新进程的上下文，然后将控制权转移到新进程</p><p><img src="C:\Users\11147\AppData\Roaming\Typora\typora-user-images\image-20221027150650716.png" alt="image-20221027150650716"></p><p>问题：进程打乱了时间的概念，使得程序员很难获得运行时间的准确和可重复测量。</p><h3 id="1-7-2-线程"><a href="#1-7-2-线程" class="headerlink" title="1.7.2 线程"></a>1.7.2 线程</h3><p>在现代系统中，一个进程实际上可以由多个称为<strong>线程</strong>的执行单元组成，每个线程都运行在进程的上下文中，并共享</p><p>同样的代码和全局数据。由于网络服务器中对并行处理的要求，线程称为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般都比进程更高效。</p><h3 id="1-7-3-虚拟存储器"><a href="#1-7-3-虚拟存储器" class="headerlink" title="1.7.3 虚拟存储器"></a>1.7.3 虚拟存储器</h3><p>虚拟存储器是一个抽象概念，他为每个进程提供了一个假象，好像每个进程都在独占地使用主存。每个进程看到的存储器都是一致的，称为虚拟地址空间</p><p><img src="C:\Users\11147\AppData\Roaming\Typora\typora-user-images\image-20221027151449695.png" alt="image-20221027151449695"></p><p><img src="C:\Users\11147\AppData\Roaming\Typora\typora-user-images\image-20221027151756802.png" alt="image-20221027151756802"></p><p>基本思想是把一个进程虚拟存储器的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。</p><h3 id="1-7-4-文件"><a href="#1-7-4-文件" class="headerlink" title="1.7.4 文件"></a>1.7.4 文件</h3><p>​    文件只不过就是字节序列，每个I/O设备，包括磁盘，键盘，显示器，甚至于网络，都可以被看成是文件。<strong>系统中所有输入输出都是通过使用称为Unix I/O的以小组系统函数调用读写文件来实现的。</strong></p><p>文件使得应用程序可以统一的看待系统中可能含有的所有各式各样的I/O设备。</p><blockquote><p>Linux,1991年8月，芬兰研究生</p></blockquote><h2 id="1-8-利用网络系统和其他系统通信"><a href="#1-8-利用网络系统和其他系统通信" class="headerlink" title="1.8 利用网络系统和其他系统通信"></a>1.8 利用网络系统和其他系统通信</h2><p>现代系统是通过网络和其它系统连接到一起的。从一个单独的设备来看，网络又可以被视为一个I/O设备，<strong>当系统从主存拷贝一串字符到网络适配器时，数据流经过网络到达另一台机器，而不是达到本地磁盘驱动器</strong></p><p><img src="C:\Users\11147\AppData\Roaming\Typora\typora-user-images\image-20221027160259170.png" alt="image-20221027160259170"></p><h2 id="1-9-下一步"><a href="#1-9-下一步" class="headerlink" title="1.9 下一步"></a>1.9 下一步</h2><p>系统不仅仅只是硬件。系统是互相交织的硬件和系统软件的集合体，他们必须共同协作以达到运行应用程序的最终目的。</p><p><img src="C:\Users\11147\AppData\Roaming\Typora\typora-user-images\image-20221027160638339.png" alt="image-20221027160638339"></p><h1 id="chapter-2-信息的表示和处理"><a href="#chapter-2-信息的表示和处理" class="headerlink" title="chapter 2 信息的表示和处理"></a>chapter 2 信息的表示和处理</h1><h2 id="2-1-信息存储"><a href="#2-1-信息存储" class="headerlink" title="2.1 信息存储"></a>2.1 信息存储</h2><p>大多数计算机使用8位的块，或叫做字节（byte），来作为最小的可寻址的存储器单位，而不是访问存储器中单独的位。机器级程序将存储器视为一个非常大的字节数组，称为虚拟存储器(virtual memory)存储器的每个字节都由一个唯一的数字来标识，称为它的地址。十六进制表示法。</p><p>十进制—-二进制—十六进制</p><p>一个字节可以被表示为两个十六进制的数字</p><h3 id="2-1-2-字"><a href="#2-1-2-字" class="headerlink" title="2.1.2 字"></a>2.1.2 字</h3><p>每台计算机都有一个字长(word size)，指明整数和指针数据的标称大小，字长决定的最重要的系统参数就是虚拟地址空间的最大大小，也就是说，对于一个字长为n的机器而言，虚拟地址的范围为0到$2^{n-1}$,程序最多访问$2^n$字节</p><h3 id="2-1-4-寻址和字节顺序"><a href="#2-1-4-寻址和字节顺序" class="headerlink" title="2.1.4 寻址和字节顺序"></a>2.1.4 寻址和字节顺序</h3><p>对于跨越多字节的程序对象，我们必须建立两个规则：</p><ul><li>这个对象的地址是什么</li><li>我们在存储器中如何对这些字节排序</li><li>详见课本</li></ul><p>某些机器选择在存储器中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储，前一种方法—最低有效字节在前的称为<strong>小端法</strong>，最高有效字节在前的称为<strong>大端法</strong></p><p><img src="C:\Users\11147\AppData\Roaming\Typora\typora-user-images\image-20221028114755118.png" alt="image-20221028114755118"></p><p>对于字节的选择是任意的</p><p>一般来将，机器的字节顺序是不可见的，无论那种类型的机器所编译的程序都会得到相同的结果。不过有时候字节顺序会称为问题。</p><ul><li>首先是在不同类型的机器之间通过网络进行传送二进制数据时。因此需要指定一个网络标准。</li><li>第二种情况是当阅读表示整数数据的字节序列时。这通常发生在检查机器级程序时。</li><li>第三种情况是当编写规避正常的系统类型的数据时。在c语言中，可以通过强制数据类型转换来编写，他们 对于系统级编程是十分有用的</li></ul><p>使用<code>printf</code>格式化输出：%c,%f,%s,%d</p><p>在c中我们能够用数组表示法来引用指针，同时我们也能用指针表示法来引用数组元素</p><p>一般来说，表达式 <code>sizeof(T)</code>返回存储一个类型为T的对象所需要的字节数。使用<code>sizeof</code>，而不是一个固定的值，是向编写在不同机器类型上可移植的代码迈进了一步。</p><h3 id="2-1-5-表示字符串"><a href="#2-1-5-表示字符串" class="headerlink" title="2.1.5 表示字符串"></a>2.1.5 表示字符串</h3><p>C中的字符串被编码为一个以null（其值为0）字符结尾的字符数组。文本数据比二进制数据具有更强的平台独立性</p><h3 id="2-1-6-表示代码"><a href="#2-1-6-表示代码" class="headerlink" title="2.1.6 表示代码"></a>2.1.6 表示代码</h3><p>二进制代码很少能在不同机器和操作系统组合之间移植。</p><p>计算机系统的一个基本概念就是从机器的角度看，程序仅仅只是字节序列。机器没有关于原始源程序的任何信息。</p><h3 id="2-1-7-布尔代数和环"><a href="#2-1-7-布尔代数和环" class="headerlink" title="2.1.7 布尔代数和环"></a>2.1.7 布尔代数和环</h3><p>将二进制值1和0编码为逻辑值true和false</p><p>~ | &amp; ^</p><p><img src="C:\Users\11147\AppData\Roaming\Typora\typora-user-images\image-20221028152322528.png" alt="image-20221028152322528"></p><h3 id="2-1-8-C中的位级运算"><a href="#2-1-8-C中的位级运算" class="headerlink" title="2.1.8 C中的位级运算"></a>2.1.8 C中的位级运算</h3><p>正如我们所说的，确定一个位级运算表达式结果的最好方法就是将十六进制参数扩展成他们的二进制表示，执行二进制运算，然后再转回十六进制</p><p>交换两个数的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">    a=a^b;</span><br><span class="line">b=a^b;</span><br><span class="line">a=a^b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-9-C中的逻辑运算"><a href="#2-1-9-C中的逻辑运算" class="headerlink" title="2.1.9 C中的逻辑运算"></a>2.1.9 C中的逻辑运算</h3><p><img src="C:\Users\11147\AppData\Roaming\Typora\typora-user-images\image-20221028160212090.png" alt="image-20221028160212090"></p><h3 id="2-1-10-C中的移位运算"><a href="#2-1-10-C中的移位运算" class="headerlink" title="2.1.10 C中的移位运算"></a>2.1.10 C中的移位运算</h3><p>向左移动K位，则会丢弃K个最高位，并右端补上K个0.</p><h2 id="2-2-整数表示"><a href="#2-2-整数表示" class="headerlink" title="2.2 整数表示"></a>2.2 整数表示</h2><h3 id="2-2-1-整型数据类型"><a href="#2-2-1-整型数据类型" class="headerlink" title="2.2.1 整型数据类型"></a>2.2.1 整型数据类型</h3><h1 id="chapter3-程序的机器级表示"><a href="#chapter3-程序的机器级表示" class="headerlink" title="chapter3 程序的机器级表示"></a>chapter3 程序的机器级表示</h1><p>在用汇编代码写程序时，程序员必须明确指定程序应该如何管理存储器(memory)和用来执行计算的低级指令。</p><p>对于严谨的程序员来说，能够阅读和理解汇编代码仍是一项很重要的技能。</p><p>我们必须了解典型的编译器在将C程序结构 变换成机器代码时所作的转换。</p><h2 id="3-2-程序编码"><a href="#3-2-程序编码" class="headerlink" title="3.2 程序编码"></a>3.2 程序编码</h2><p>假设我们写一个C程序，有两个文件p1.c 和p2.c 然后我们进行编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o2 -o p p1.c p2.c</span><br></pre></td></tr></table></figure><p>命令gcc表明的就是gnu C编译器GCC。编译选项-o2高速编译器使用第二级优化。（提高优化级别会使最终程序运行的快，但是编译时间会变长，第二级优化就是两种方式的妥协）</p><blockquote><p>首先，C预处理器会扩展源代码，插入所有用#include命令指定的文件，并扩展所有的宏。其次，编译器产生两个源文件的汇编代码，名字分别为p1.s和p2.s。接下来汇编器会将汇编代码转化成二进制目标代码文件p1.o和p2.o。最后，<strong>链接器</strong>会将两个目标文件与与实现标准Unix库函数（例如<code>printf</code>）的代码合并，并产生最终的可执行文件。</p></blockquote><h3 id="3-2-1-机器级代码"><a href="#3-2-1-机器级代码" class="headerlink" title="3.2.1 机器级代码"></a>3.2.1 机器级代码</h3><p>汇编代码非常接近于机器代码。与目标代码的二进制格式相比，汇编代码的主要特点是用可读性更好的文本格式表示的。能够理解汇编代码以及它是如何与原始的C代码相对应的，是理解计算机如何执行程序的关键一步。</p><p>要查看目标代码文件的内容，有一类称为反汇编器(disassembler)的程序的价值无法估量，这些程序根据目标代码生成一种类似于汇编代码的格式。在Linux系统中，带“-d”命令行选型的程序 <code>objdump</code>可以充当这个角色：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d code.o</span><br></pre></td></tr></table></figure><p><img src="C:\Users\11147\AppData\Roaming\Typora\typora-user-images\image-20221028200630587.png" alt="image-20221028200630587"></p><h3 id="3-2-3-关于格式的注解"><a href="#3-2-3-关于格式的注解" class="headerlink" title="3.2.3 关于格式的注解"></a>3.2.3 关于格式的注解</h3><p><img src="C:\Users\11147\AppData\Roaming\Typora\typora-user-images\image-20221028201555766.png" alt="image-20221028201555766"></p><h2 id="3-3-数据格式"><a href="#3-3-数据格式" class="headerlink" title="3.3 数据格式"></a>3.3 数据格式</h2><p>Intel用术语“word”表示16位数据类型。因此称32位为“double words”</p><p><img src="C:\Users\11147\AppData\Roaming\Typora\typora-user-images\image-20221028202002406.png" alt="image-20221028202002406"></p><p>GAS的每一个才做都有一个字符后缀，表明操作数的大小。例如，<code>movb</code>（传送字节）、<code>movl</code>（传送双字）</p><h2 id="3-4-访问信息"><a href="#3-4-访问信息" class="headerlink" title="3.4 访问信息"></a>3.4 访问信息</h2><p>一个IA32中央处理单元（CPU）包含一组八个存储32位值得寄存器，这些寄存器用来存储整数数据和指针</p><p><img src="C:\Users\11147\AppData\Roaming\Typora\typora-user-images\image-20221028202524059.png" alt="image-20221028202524059"></p><p>在大多数情况中，前六个寄存器都可以看成通用寄存器，对他们的使用没有限制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深入理解计算机系统笔记&quot;&gt;&lt;a href=&quot;#深入理解计算机系统笔记&quot; class=&quot;headerlink&quot; title=&quot;深入理解计算机系统笔记&quot;&gt;&lt;/a&gt;深入理解计算机系统笔记&lt;/h1&gt;&lt;h2 id=&quot;1-4系统的硬件组成&quot;&gt;&lt;a href=&quot;#1-4系统的硬</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://michael8023.github.io/post/4a17b156.html"/>
    <id>http://michael8023.github.io/post/4a17b156.html</id>
    <published>2022-10-29T13:20:05.693Z</published>
    <updated>2022-10-29T14:08:44.946Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
